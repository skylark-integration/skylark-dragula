{"version":3,"sources":["_drake.js"],"names":["define","skylark","Emitter","mouse","touch","noder","finder","geom","eventer","styler","helpers","inherit","_source","_item","_initialSibling","_currentSibling","_renderTimer","_copy","_lastDropTarget","_prepareArgs","e","args","init","options","this","containers","destroy","dragging","isContainer","el","indexOf","isCopy","item","container","o","copy","findDropTarget","clientX","clientY","elementBehindCursor","fromPoint","target","self","accepted","parent","immediate","getImmediateChild","reference","getReference","isInitialPlacement","accepts","s","sibling","nextSibling","dropTarget","x","y","horizontal","direction","rect","boundingRect","resolve","left","getRectWidth","top","getRectHeight","inside","len","children","length","i","width","height","outside","after","root","canStart","ignoreInputTextSelection","isInput","handle","invalid","source","moves","canMove","manualStart","context","start","cloneNode","emit","over","changed","moved","copySortSource","revertOnSpill","removeChild","insertBefore","type","end","drop","cleanup","remove","cancel","revert","reverts","arguments","initial","removeClass","clearTimeout"],"mappings":"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","file":"../_drake.js","sourcesContent":["define([\r\n  \"skylark-langx/skylark\",\r\n  \"skylark-langx-emitter/Emitter\",\r\n  \"skylark-devices-points/mouse\",\r\n  \"skylark-devices-points/touch\",\r\n  \"skylark-domx-noder\",\r\n  \"skylark-domx-finder\",\r\n  \"skylark-domx-geom\",\r\n  \"skylark-domx-eventer\",\r\n  \"skylark-domx-styler\",\r\n  \"./_helpers\"\r\n],function(\r\n  skylark,\r\n  Emitter,\r\n  mouse,\r\n  touch,\r\n  noder,\r\n  finder,\r\n  geom,\r\n  eventer,\r\n  styler,\r\n  helpers\r\n){\r\n    'use strict';\r\n\r\n\r\n    var Drake = Emitter.inherit({\r\n        _source : null,   // source container\r\n        _item : null,     // item being dragged\r\n        _initialSibling : null, // reference sibling when grabbed\r\n        _currentSibling : null, // reference sibling now\r\n        _renderTimer : null, // timer for setTimeout renderMirrorImage\r\n        _copy : null, // item used for copying\r\n        _lastDropTarget : null, // last container item was over\r\n\r\n        _prepareArgs : function(e,args) {\r\n            return args;\r\n        },\r\n        init : function(options) {\r\n            this.containers = options.containers;\r\n            this.destroy = options.destroy;\r\n            this.options = options;\r\n            this.dragging = false;\r\n\r\n        },\r\n\r\n        isContainer : function(el) {\r\n            return this.containers.indexOf(el) !== -1 || this.options.isContainer(el);\r\n        },\r\n   \r\n        isCopy : function  (item, container) {\r\n            var o = this.options;\r\n            return typeof o.copy === 'boolean' ? o.copy : o.copy(item, container);\r\n        },\r\n\r\n\r\n        findDropTarget : function  (clientX, clientY) {\r\n            var elementBehindCursor  = noder.fromPoint(clientX, clientY),\r\n                target = elementBehindCursor,\r\n                self = this;\r\n\r\n            while (target && !accepted()) {\r\n              target = finder.parent(target);\r\n            }\r\n\r\n            return target;\r\n\r\n            function accepted () {\r\n              var droppable = self.isContainer(target);\r\n              if (droppable === false) {\r\n                return false;\r\n              }\r\n\r\n              var immediate = self.getImmediateChild(target, elementBehindCursor);\r\n              var reference = self.getReference(target, immediate, clientX, clientY);\r\n              var initial = self.isInitialPlacement(target, reference);\r\n              if (initial) {\r\n                return true; // should always be able to drop it right back where it was\r\n              }\r\n              return self.options.accepts(self._item, target, self._source, reference);\r\n            }\r\n        },\r\n\r\n        isInitialPlacement : function  (target, s) {\r\n            var sibling;\r\n            if (s !== void 0) {\r\n              sibling = s;\r\n            ///} else if (_mirror) {\r\n            ///  sibling = _currentSibling;\r\n            } else {\r\n              sibling = finder.nextSibling(this._copy || this._item);\r\n            }\r\n            return target === this._source && sibling === this._initialSibling;\r\n        },\r\n\r\n        getReference : function(dropTarget, target, x, y) {\r\n            var o = this.options;\r\n\r\n            var horizontal = o.direction === 'horizontal';\r\n\r\n            if (target !== dropTarget) {\r\n                return inside();\r\n            }  else {\r\n                return  outside();\r\n            }\r\n\r\n            return reference;\r\n\r\n            function outside () { // slower, but able to figure out any position\r\n              var len = dropTarget.children.length;\r\n\r\n              for (let i = 0; i < len; i++) {\r\n                let el = dropTarget.children[i];\r\n                //rect = el.getBoundingClientRect();\r\n                let rect = geom.boundingRect(el);\r\n                if (horizontal && (rect.left + rect.width / 2) > x) { return el; }\r\n                if (!horizontal && (rect.top + rect.height / 2) > y) { return el; }\r\n              }\r\n              return null;\r\n            }\r\n\r\n\r\n            function inside () { // faster, but only available if dropped inside a child element\r\n              \r\n              //var rect = target.getBoundingClientRect();\r\n              var  rect = geom.boundingRect(target);\r\n              if (horizontal) {\r\n                return resolve(x > rect.left + helpers.getRectWidth(rect) / 2);\r\n              }\r\n              return resolve(y > rect.top + helpers.getRectHeight(rect) / 2);\r\n              \r\n            }\r\n\r\n            function resolve (after) {\r\n              return after ? finder.nextSibling(target) : target;\r\n            }\r\n        },\r\n\r\n\r\n        getImmediateChild :   function(dropTarget, target) {\r\n            var immediate = target;\r\n            while (immediate !== dropTarget && finder.parent(immediate) !== dropTarget) {\r\n              immediate = finder.parent(immediate);\r\n            }\r\n            if (immediate === noder.root()) {\r\n              return null;\r\n            }\r\n            return immediate;\r\n        },\r\n\r\n        canStart : function (item) {\r\n            ///if (drake.dragging && _mirror) {\r\n            if (this.dragging) {\r\n              return;\r\n            }\r\n            if (this.isContainer(item)) {\r\n              return; // don't drag container itself\r\n            }\r\n\r\n            if (this.options.ignoreInputTextSelection) {\r\n                ///var clientX = getCoord('clientX', e);\r\n                ///var clientY = getCoord('clientY', e);\r\n                /////var elementBehindCursor = doc.elementFromPoint(clientX, clientY);\r\n                ///var elementBehindCursor = noder.fromPoint(clientX,clientY);\r\n                ///if (noder.isInput(elementBehindCursor)) {\r\n                if (noder.isInput(item)){\r\n                    return;\r\n                }\r\n            }\r\n\r\n\r\n            var handle = item;\r\n            var o = this.options;\r\n            while (finder.parent(item) && this.isContainer(finder.parent(item)) === false) {\r\n              if (o.invalid(item, handle)) {\r\n                return;\r\n              }\r\n              item = finder.parent(item); // drag target should be a top element\r\n              if (!item) {\r\n                return;\r\n              }\r\n            }\r\n            var source = finder.parent(item);\r\n            if (!source) {\r\n              return;\r\n            }\r\n            if (o.invalid(item, handle)) {\r\n              return;\r\n            }\r\n\r\n            var movable = o.moves(item, source, handle, finder.nextSibling(item));\r\n            if (!movable) {\r\n              return;\r\n            }\r\n\r\n            return {\r\n              item: item,\r\n              source: source\r\n            };\r\n        },\r\n\r\n        canMove : function  (item) {\r\n            return !! this.canStart(item);\r\n        },\r\n\r\n        manualStart : function (item) {\r\n            var context = this.canStart(item);\r\n            if (context) {\r\n                this.start(context);\r\n            }\r\n        },\r\n\r\n        start : function(context) {\r\n            if (this.isCopy(context.item, context.source)) {\r\n              this._copy = context.item.cloneNode(true);\r\n              this.emit('cloned', this._copy, context.item, 'copy');\r\n            }\r\n\r\n            this._source = context.source;\r\n            this._item = context.item;\r\n            this._initialSibling = this._currentSibling = finder.nextSibling(context.item);\r\n\r\n            this.dragging = true;\r\n            this.emit('drag', this._item, this._source);\r\n        },\r\n\r\n        over : function(clientX,clientY) {\r\n            var o = this.options,\r\n                item = this._copy || this._item,\r\n                self = this;\r\n\r\n\r\n            var elementBehindCursor = noder.fromPoint( clientX, clientY);\r\n            var dropTarget = this.findDropTarget(clientX, clientY);\r\n            var changed = dropTarget !== null && dropTarget !== this._lastDropTarget;\r\n            if (changed || dropTarget === null) {\r\n              out();\r\n              this._lastDropTarget = dropTarget;\r\n              over();\r\n            }\r\n            var parent = finder.parent(item);\r\n            if (dropTarget === this._source && this._copy && !o.copySortSource) {\r\n              if (parent) {\r\n                parent.removeChild(item);\r\n              }\r\n              return;\r\n            }\r\n\r\n            var reference;\r\n            var immediate = this.getImmediateChild(dropTarget, elementBehindCursor);\r\n            if (immediate !== null) {\r\n              reference = this.getReference(dropTarget, immediate, clientX, clientY);\r\n            } else if (o.revertOnSpill === true && !this._copy) {\r\n              reference = this._initialSibling;\r\n              dropTarget = this._source;\r\n            } else {\r\n              if (this._copy && parent) {\r\n                parent.removeChild(item);\r\n              }\r\n              return;\r\n            }\r\n            if (\r\n              (reference === null && changed) ||\r\n              reference !== item &&\r\n              reference !== finder.nextSibling(item)\r\n            ) {\r\n              this._currentSibling = reference;\r\n              dropTarget.insertBefore(item, reference);\r\n              this.emit('shadow', item, dropTarget, this._source);\r\n            }\r\n\r\n            \r\n            function moved (type) { \r\n                self.emit(type, item, self._lastDropTarget, self._source); \r\n            }\r\n            \r\n            function over () { \r\n                if (changed) { \r\n                    moved('over'); \r\n                } \r\n            }\r\n            \r\n            function out () { \r\n                if (self._lastDropTarget) { \r\n                    moved('out'); \r\n                } \r\n            }\r\n        },\r\n\r\n        end : function() {\r\n            if (!this.dragging) {\r\n              return;\r\n            }\r\n            var item = this._copy || this._item;\r\n            this.drop(item, finder.parent(item));\r\n        },\r\n\r\n        drop : function(item, target) {\r\n            var parent = finder.parent(item);\r\n            if (this._copy && this.options.copySortSource && target === this._source) {\r\n              parent.removeChild(this._item);\r\n            }\r\n            if (this.isInitialPlacement(target)) {\r\n              this.emit('cancel', item, this._source, this._source);\r\n            } else {\r\n              this.emit('drop', item, target, this._source, this._currentSibling);\r\n            }\r\n            this.cleanup();\r\n        },\r\n\r\n        remove : function () {\r\n            if (!this.dragging) {\r\n              return;\r\n            }\r\n            var item = this._copy || this._item;\r\n            var parent = finder.parent(item);\r\n            if (parent) {\r\n              parent.removeChild(item);\r\n            }\r\n            this.emit(_copy ? 'cancel' : 'remove', item, parent, this._source);\r\n            this.cleanup();\r\n        },\r\n\r\n        cancel : function  (revert) {\r\n            if (!this.dragging) {\r\n              return;\r\n            }\r\n            var o = this.options;\r\n\r\n            var reverts = arguments.length > 0 ? revert : o.revertOnSpill;\r\n            var item = this._copy || this._item;\r\n            var parent = finder.parent(item);\r\n            var initial = this.isInitialPlacement(parent);\r\n            if (initial === false && reverts) {\r\n              if (this._copy) {\r\n                if (parent) {\r\n                  parent.removeChild(this._copy);\r\n                }\r\n              } else {\r\n                this._source.insertBefore(item, this._initialSibling);\r\n              }\r\n            }\r\n            if (initial || reverts) {\r\n              this.emit('cancel', item, this._source, this._source);\r\n            } else {\r\n              this.emit('drop', item, parent, this._source, this._currentSibling);\r\n            }\r\n            this.cleanup();\r\n        },\r\n\r\n        cleanup : function  () {\r\n            var item = this._copy || this._item;\r\n            ///ungrab();\r\n            ///removeMirrorImage();\r\n            if (item) {\r\n              styler.removeClass(item, 'gu-transit');\r\n            }\r\n            if (this._renderTimer) {\r\n              clearTimeout(_renderTimer);\r\n            }\r\n            this.dragging = false;\r\n            if (this._lastDropTarget) {\r\n              this.emit('out', item, this._lastDropTarget, this._source);\r\n            }\r\n            this.emit('dragend', item);\r\n\r\n            this._source = \r\n            this._item = \r\n            this._copy = \r\n            this._initialSibling = \r\n            this._currentSibling = \r\n            this._renderTimer = \r\n            this._lastDropTarget = null;\r\n        }\r\n\r\n\r\n    });\r\n\r\n    \r\n    return Drake;\r\n});"]}