{"version":3,"sources":["_drake.js"],"names":["define","skylark","Emitter","mouse","touch","noder","finder","geom","eventer","styler","helpers","inherit","_source","_item","_initialSibling","_currentSibling","_renderTimer","_copy","_lastDropTarget","_prepareArgs","e","args","init","options","this","containers","destroy","isContainer","el","indexOf","isCopy","item","container","o","copy","findDropTarget","clientX","clientY","elementBehindCursor","fromPoint","target","self","accepted","parent","immediate","getImmediateChild","reference","getReference","isInitialPlacement","accepts","s","sibling","nextSibling","dropTarget","x","y","horizontal","direction","rect","boundingRect","resolve","left","getRectWidth","top","getRectHeight","inside","len","children","length","i","width","height","outside","after","root","canStart","dragging","ignoreInputTextSelection","isInput","handle","invalid","source","moves","canMove","manualStart","context","start","cloneNode","emit","over","changed","moved","copySortSource","revertOnSpill","removeChild","insertBefore","type","end","drop","cleanup","remove","cancel","revert","reverts","arguments","initial","removeClass","clearTimeout"],"mappings":"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","file":"../_drake.js","sourcesContent":["define([\r\n  \"skylark-langx/skylark\",\r\n  \"skylark-langx-emitter/Emitter\",\r\n  \"skylark-devices-points/mouse\",\r\n  \"skylark-devices-points/touch\",\r\n  \"skylark-domx-noder\",\r\n  \"skylark-domx-finder\",\r\n  \"skylark-domx-geom\",\r\n  \"skylark-domx-eventer\",\r\n  \"skylark-domx-styler\",\r\n  \"./_helpers\"\r\n],function(\r\n  skylark,\r\n  Emitter,\r\n  mouse,\r\n  touch,\r\n  noder,\r\n  finder,\r\n  geom,\r\n  eventer,\r\n  styler,\r\n  helpers\r\n){\r\n    'use strict';\r\n\r\n\r\n    var Drake = Emitter.inherit({\r\n        _source : null,   // source container\r\n        _item : null,     // item being dragged\r\n        _initialSibling : null, // reference sibling when grabbed\r\n        _currentSibling : null, // reference sibling now\r\n        _renderTimer : null, // timer for setTimeout renderMirrorImage\r\n        _copy : null, // item used for copying\r\n        _lastDropTarget : null, // last container item was over\r\n\r\n        _prepareArgs : function(e,args) {\r\n            return args;\r\n        },\r\n        init : function(options) {\r\n            this.containers = options.containers;\r\n            this.destroy = options.destroy;\r\n            this.options = options;\r\n        },\r\n\r\n        isContainer : function(el) {\r\n            return this.containers.indexOf(el) !== -1 || this.options.isContainer(el);\r\n        },\r\n   \r\n        isCopy : function  (item, container) {\r\n            var o = this.options;\r\n            return typeof o.copy === 'boolean' ? o.copy : o.copy(item, container);\r\n        },\r\n\r\n\r\n        findDropTarget : function  (clientX, clientY) {\r\n            var elementBehindCursor  = noder.fromPoint(clientX, clientY),\r\n                target = elementBehindCursor,\r\n                self = this;\r\n\r\n            while (target && !accepted()) {\r\n              target = finder.parent(target);\r\n            }\r\n\r\n            return target;\r\n\r\n            function accepted () {\r\n              var droppable = self.isContainer(target);\r\n              if (droppable === false) {\r\n                return false;\r\n              }\r\n\r\n              var immediate = self.getImmediateChild(target, elementBehindCursor);\r\n              var reference = self.getReference(target, immediate, clientX, clientY);\r\n              var initial = self.isInitialPlacement(target, reference);\r\n              if (initial) {\r\n                return true; // should always be able to drop it right back where it was\r\n              }\r\n              return self.options.accepts(self._item, target, self._source, reference);\r\n            }\r\n        },\r\n\r\n        isInitialPlacement : function  (target, s) {\r\n            var sibling;\r\n            if (s !== void 0) {\r\n              sibling = s;\r\n            ///} else if (_mirror) {\r\n            ///  sibling = _currentSibling;\r\n            } else {\r\n              sibling = finder.nextSibling(this._copy || this._item);\r\n            }\r\n            return target === this._source && sibling === this._initialSibling;\r\n        },\r\n\r\n        getReference : function(dropTarget, target, x, y) {\r\n            var o = this.options;\r\n\r\n            var horizontal = o.direction === 'horizontal';\r\n\r\n            if (target !== dropTarget) {\r\n                return inside();\r\n            }  else {\r\n                return  outside();\r\n            }\r\n\r\n            return reference;\r\n\r\n            function outside () { // slower, but able to figure out any position\r\n              var len = dropTarget.children.length;\r\n\r\n              for (let i = 0; i < len; i++) {\r\n                let el = dropTarget.children[i];\r\n                //rect = el.getBoundingClientRect();\r\n                let rect = geom.boundingRect(el);\r\n                if (horizontal && (rect.left + rect.width / 2) > x) { return el; }\r\n                if (!horizontal && (rect.top + rect.height / 2) > y) { return el; }\r\n              }\r\n              return null;\r\n            }\r\n\r\n\r\n            function inside () { // faster, but only available if dropped inside a child element\r\n              \r\n              //var rect = target.getBoundingClientRect();\r\n              var  rect = geom.boundingRect(target);\r\n              if (horizontal) {\r\n                return resolve(x > rect.left + helpers.getRectWidth(rect) / 2);\r\n              }\r\n              return resolve(y > rect.top + helpers.getRectHeight(rect) / 2);\r\n              \r\n            }\r\n\r\n            function resolve (after) {\r\n              return after ? finder.nextSibling(target) : target;\r\n            }\r\n        },\r\n\r\n\r\n        getImmediateChild :   function(dropTarget, target) {\r\n            var immediate = target;\r\n            while (immediate !== dropTarget && finder.parent(immediate) !== dropTarget) {\r\n              immediate = finder.parent(immediate);\r\n            }\r\n            if (immediate === noder.root()) {\r\n              return null;\r\n            }\r\n            return immediate;\r\n        },\r\n\r\n        canStart : function (item) {\r\n            ///if (drake.dragging && _mirror) {\r\n            if (this.dragging) {\r\n              return;\r\n            }\r\n            if (this.isContainer(item)) {\r\n              return; // don't drag container itself\r\n            }\r\n\r\n            if (this.options.ignoreInputTextSelection) {\r\n                ///var clientX = getCoord('clientX', e);\r\n                ///var clientY = getCoord('clientY', e);\r\n                /////var elementBehindCursor = doc.elementFromPoint(clientX, clientY);\r\n                ///var elementBehindCursor = noder.fromPoint(clientX,clientY);\r\n                ///if (noder.isInput(elementBehindCursor)) {\r\n                if (noder.isInput(item)){\r\n                    return;\r\n                }\r\n            }\r\n\r\n\r\n            var handle = item;\r\n            var o = this.options;\r\n            while (finder.parent(item) && this.isContainer(finder.parent(item)) === false) {\r\n              if (o.invalid(item, handle)) {\r\n                return;\r\n              }\r\n              item = finder.parent(item); // drag target should be a top element\r\n              if (!item) {\r\n                return;\r\n              }\r\n            }\r\n            var source = finder.parent(item);\r\n            if (!source) {\r\n              return;\r\n            }\r\n            if (o.invalid(item, handle)) {\r\n              return;\r\n            }\r\n\r\n            var movable = o.moves(item, source, handle, finder.nextSibling(item));\r\n            if (!movable) {\r\n              return;\r\n            }\r\n\r\n            return {\r\n              item: item,\r\n              source: source\r\n            };\r\n        },\r\n\r\n        canMove : function  (item) {\r\n            return !! this.canStart(item);\r\n        },\r\n\r\n        manualStart : function (item) {\r\n            var context = this.canStart(item);\r\n            if (context) {\r\n                this.start(context);\r\n            }\r\n        },\r\n\r\n        start : function(context) {\r\n            if (this.isCopy(context.item, context.source)) {\r\n              this._copy = context.item.cloneNode(true);\r\n              this.emit('cloned', this._copy, context.item, 'copy');\r\n            }\r\n\r\n            this._source = context.source;\r\n            this._item = context.item;\r\n            this._initialSibling = this._currentSibling = finder.nextSibling(context.item);\r\n\r\n            this.dragging = true;\r\n            this.emit('drag', this._item, this._source);\r\n        },\r\n\r\n        over : function(clientX,clientY) {\r\n            var o = this.options,\r\n                item = this._copy || this._item,\r\n                self = this;\r\n\r\n\r\n            var elementBehindCursor = noder.fromPoint( clientX, clientY);\r\n            var dropTarget = this.findDropTarget(clientX, clientY);\r\n            var changed = dropTarget !== null && dropTarget !== this._lastDropTarget;\r\n            if (changed || dropTarget === null) {\r\n              out();\r\n              this._lastDropTarget = dropTarget;\r\n              over();\r\n            }\r\n            var parent = finder.parent(item);\r\n            if (dropTarget === this._source && this._copy && !o.copySortSource) {\r\n              if (parent) {\r\n                parent.removeChild(item);\r\n              }\r\n              return;\r\n            }\r\n\r\n            var reference;\r\n            var immediate = this.getImmediateChild(dropTarget, elementBehindCursor);\r\n            if (immediate !== null) {\r\n              reference = this.getReference(dropTarget, immediate, clientX, clientY);\r\n            } else if (o.revertOnSpill === true && !this._copy) {\r\n              reference = this._initialSibling;\r\n              dropTarget = this._source;\r\n            } else {\r\n              if (this._copy && parent) {\r\n                parent.removeChild(item);\r\n              }\r\n              return;\r\n            }\r\n            if (\r\n              (reference === null && changed) ||\r\n              reference !== item &&\r\n              reference !== finder.nextSibling(item)\r\n            ) {\r\n              this._currentSibling = reference;\r\n              dropTarget.insertBefore(item, reference);\r\n              this.emit('shadow', item, dropTarget, this._source);\r\n            }\r\n\r\n            \r\n            function moved (type) { \r\n                self.emit(type, item, self._lastDropTarget, self._source); \r\n            }\r\n            \r\n            function over () { \r\n                if (changed) { \r\n                    moved('over'); \r\n                } \r\n            }\r\n            \r\n            function out () { \r\n                if (self._lastDropTarget) { \r\n                    moved('out'); \r\n                } \r\n            }\r\n        },\r\n\r\n        end : function() {\r\n            if (!this.dragging) {\r\n              return;\r\n            }\r\n            var item = this._copy || this._item;\r\n            this.drop(item, finder.parent(item));\r\n        },\r\n\r\n        drop : function(item, target) {\r\n            var parent = finder.parent(item);\r\n            if (this._copy && this.options.copySortSource && target === this._source) {\r\n              parent.removeChild(this._item);\r\n            }\r\n            if (this.isInitialPlacement(target)) {\r\n              this.emit('cancel', item, this._source, this._source);\r\n            } else {\r\n              this.emit('drop', item, target, this._source, this._currentSibling);\r\n            }\r\n            this.cleanup();\r\n        },\r\n\r\n        remove : function () {\r\n            if (!this.dragging) {\r\n              return;\r\n            }\r\n            var item = this._copy || this._item;\r\n            var parent = finder.parent(item);\r\n            if (parent) {\r\n              parent.removeChild(item);\r\n            }\r\n            this.emit(_copy ? 'cancel' : 'remove', item, parent, this._source);\r\n            this.cleanup();\r\n        },\r\n\r\n        cancel : function  (revert) {\r\n            if (!this.dragging) {\r\n              return;\r\n            }\r\n            var o = this.options;\r\n\r\n            var reverts = arguments.length > 0 ? revert : o.revertOnSpill;\r\n            var item = this._copy || this._item;\r\n            var parent = finder.parent(item);\r\n            var initial = this.isInitialPlacement(parent);\r\n            if (initial === false && reverts) {\r\n              if (this._copy) {\r\n                if (parent) {\r\n                  parent.removeChild(this._copy);\r\n                }\r\n              } else {\r\n                this._source.insertBefore(item, this._initialSibling);\r\n              }\r\n            }\r\n            if (initial || reverts) {\r\n              this.emit('cancel', item, this._source, this._source);\r\n            } else {\r\n              this.emit('drop', item, parent, this._source, this._currentSibling);\r\n            }\r\n            this.cleanup();\r\n        },\r\n\r\n        cleanup : function  () {\r\n            var item = this._copy || this._item;\r\n            ///ungrab();\r\n            ///removeMirrorImage();\r\n            if (item) {\r\n              styler.removeClass(item, 'gu-transit');\r\n            }\r\n            if (this._renderTimer) {\r\n              clearTimeout(_renderTimer);\r\n            }\r\n            this.dragging = false;\r\n            if (this._lastDropTarget) {\r\n              this.emit('out', item, this._lastDropTarget, this._source);\r\n            }\r\n            this.emit('dragend', item);\r\n\r\n            this._source = \r\n            this._item = \r\n            this._copy = \r\n            this._initialSibling = \r\n            this._currentSibling = \r\n            this._renderTimer = \r\n            this._lastDropTarget = null;\r\n        }\r\n\r\n\r\n    });\r\n\r\n    \r\n    return Drake;\r\n});"]}