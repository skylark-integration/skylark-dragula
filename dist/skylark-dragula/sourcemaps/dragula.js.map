{"version":3,"sources":["dragula.js"],"names":["define","skylark","emitter","crossvent","classes","global","window","doc","document","documentElement","touchy","el","op","type","fn","navigator","pointerEnabled","mouseup","mousedown","mousemove","msPointerEnabled","whichMouseButton","e","touches","length","which","buttons","button","getScroll","scrollProp","offsetProp","clientHeight","body","getElementBehindPoint","point","x","y","p","state","className","elementFromPoint","never","always","getRectWidth","rect","width","right","left","getRectHeight","height","bottom","top","getParent","parentNode","isInput","tagName","isEditable","contentEditable","nextEl","nextElementSibling","sibling","nextSibling","nodeType","manually","getCoord","coord","host","targetTouches","changedTouches","getEventHost","missMap","pageX","pageY","dragula","initialContainers","options","_mirror","_source","_item","_offsetX","_offsetY","_moveX","_moveY","_initialSibling","_currentSibling","_copy","_renderTimer","arguments","Array","isArray","_grabbed","_lastDropTarget","o","moves","accepts","invalid","containers","isContainer","copy","copySortSource","revertOnSpill","removeOnSpill","direction","ignoreInputTextSelection","mirrorContainer","drake","start","item","context","canStart","end","cancel","remove","destroy","events","release","canMove","dragging","on","rm","add","indexOf","grab","eventualMovements","startBecauseMouseMoved","movements","preventGrabbed","preventDefault","clientX","clientY","metaKey","ctrlKey","target","focus","grabbed","offset","getBoundingClientRect","cloneNode","style","appendChild","drag","emit","renderMirrorImage","handle","source","container","drop","ungrab","dropTarget","findDropTarget","parent","removeChild","isInitialPlacement","cleanup","revert","reverts","initial","insertBefore","clearTimeout","s","elementBehindCursor","accepted","immediate","getImmediateChild","reference","getReference","changed","moved","horizontal","resolve","i","len","children","outside","after"],"mappings":"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","file":"../dragula.js","sourcesContent":["define([\r\n  \"skylark-langx/skylark\",\r\n  \"./emitter\",\r\n  \"./crossvent\",\r\n  \"./classes\"\r\n],function(skylark,emitter,crossvent,classes){\r\n\r\n    'use strict';\r\n    var global = window;\r\n\r\n    var doc = global.document;\r\n    var documentElement = doc.documentElement;\r\n\r\n    function dragula (initialContainers, options) {\r\n      var len = arguments.length;\r\n      if (len === 1 && Array.isArray(initialContainers) === false) {\r\n        options = initialContainers;\r\n        initialContainers = [];\r\n      }\r\n      var _mirror; // mirror image\r\n      var _source; // source container\r\n      var _item; // item being dragged\r\n      var _offsetX; // reference x\r\n      var _offsetY; // reference y\r\n      var _moveX; // reference move x\r\n      var _moveY; // reference move y\r\n      var _initialSibling; // reference sibling when grabbed\r\n      var _currentSibling; // reference sibling now\r\n      var _copy; // item used for copying\r\n      var _renderTimer; // timer for setTimeout renderMirrorImage\r\n      var _lastDropTarget = null; // last container item was over\r\n      var _grabbed; // holds mousedown context until first mousemove\r\n\r\n      var o = options || {};\r\n      if (o.moves === void 0) { o.moves = always; }\r\n      if (o.accepts === void 0) { o.accepts = always; }\r\n      if (o.invalid === void 0) { o.invalid = invalidTarget; }\r\n      if (o.containers === void 0) { o.containers = initialContainers || []; }\r\n      if (o.isContainer === void 0) { o.isContainer = never; }\r\n      if (o.copy === void 0) { o.copy = false; }\r\n      if (o.copySortSource === void 0) { o.copySortSource = false; }\r\n      if (o.revertOnSpill === void 0) { o.revertOnSpill = false; }\r\n      if (o.removeOnSpill === void 0) { o.removeOnSpill = false; }\r\n      if (o.direction === void 0) { o.direction = 'vertical'; }\r\n      if (o.ignoreInputTextSelection === void 0) { o.ignoreInputTextSelection = true; }\r\n      if (o.mirrorContainer === void 0) { o.mirrorContainer = doc.body; }\r\n\r\n      var drake = emitter({\r\n        containers: o.containers,\r\n        start: manualStart,\r\n        end: end,\r\n        cancel: cancel,\r\n        remove: remove,\r\n        destroy: destroy,\r\n        canMove: canMove,\r\n        dragging: false\r\n      });\r\n\r\n      if (o.removeOnSpill === true) {\r\n        drake.on('over', spillOver).on('out', spillOut);\r\n      }\r\n\r\n      events();\r\n\r\n      return drake;\r\n\r\n      function isContainer (el) {\r\n        return drake.containers.indexOf(el) !== -1 || o.isContainer(el);\r\n      }\r\n\r\n      function events (remove) {\r\n        var op = remove ? 'remove' : 'add';\r\n        touchy(documentElement, op, 'mousedown', grab);\r\n        touchy(documentElement, op, 'mouseup', release);\r\n      }\r\n\r\n      function eventualMovements (remove) {\r\n        var op = remove ? 'remove' : 'add';\r\n        touchy(documentElement, op, 'mousemove', startBecauseMouseMoved);\r\n      }\r\n\r\n      function movements (remove) {\r\n        var op = remove ? 'remove' : 'add';\r\n        crossvent[op](documentElement, 'selectstart', preventGrabbed); // IE8\r\n        crossvent[op](documentElement, 'click', preventGrabbed);\r\n      }\r\n\r\n      function destroy () {\r\n        events(true);\r\n        release({});\r\n      }\r\n\r\n      function preventGrabbed (e) {\r\n        if (_grabbed) {\r\n          e.preventDefault();\r\n        }\r\n      }\r\n\r\n      function grab (e) {\r\n        _moveX = e.clientX;\r\n        _moveY = e.clientY;\r\n\r\n        var ignore = whichMouseButton(e) !== 1 || e.metaKey || e.ctrlKey;\r\n        if (ignore) {\r\n          return; // we only care about honest-to-god left clicks and touch events\r\n        }\r\n        var item = e.target;\r\n        var context = canStart(item);\r\n        if (!context) {\r\n          return;\r\n        }\r\n        _grabbed = context;\r\n        eventualMovements();\r\n        if (e.type === 'mousedown') {\r\n          if (isInput(item)) { // see also: https://github.com/bevacqua/dragula/issues/208\r\n            item.focus(); // fixes https://github.com/bevacqua/dragula/issues/176\r\n          } else {\r\n            e.preventDefault(); // fixes https://github.com/bevacqua/dragula/issues/155\r\n          }\r\n        }\r\n      }\r\n\r\n      function startBecauseMouseMoved (e) {\r\n        if (!_grabbed) {\r\n          return;\r\n        }\r\n        if (whichMouseButton(e) === 0) {\r\n          release({});\r\n          return; // when text is selected on an input and then dragged, mouseup doesn't fire. this is our only hope\r\n        }\r\n        // truthy check fixes #239, equality fixes #207\r\n        if (e.clientX !== void 0 && e.clientX === _moveX && e.clientY !== void 0 && e.clientY === _moveY) {\r\n          return;\r\n        }\r\n        if (o.ignoreInputTextSelection) {\r\n          var clientX = getCoord('clientX', e);\r\n          var clientY = getCoord('clientY', e);\r\n          var elementBehindCursor = doc.elementFromPoint(clientX, clientY);\r\n          if (isInput(elementBehindCursor)) {\r\n            return;\r\n          }\r\n        }\r\n\r\n        var grabbed = _grabbed; // call to end() unsets _grabbed\r\n        eventualMovements(true);\r\n        movements();\r\n        end();\r\n        start(grabbed);\r\n\r\n        var offset = getOffset(_item);\r\n        _offsetX = getCoord('pageX', e) - offset.left;\r\n        _offsetY = getCoord('pageY', e) - offset.top;\r\n\r\n        classes.add(_copy || _item, 'gu-transit');\r\n        renderMirrorImage();\r\n        drag(e);\r\n      }\r\n\r\n      function canStart (item) {\r\n        if (drake.dragging && _mirror) {\r\n          return;\r\n        }\r\n        if (isContainer(item)) {\r\n          return; // don't drag container itself\r\n        }\r\n        var handle = item;\r\n        while (getParent(item) && isContainer(getParent(item)) === false) {\r\n          if (o.invalid(item, handle)) {\r\n            return;\r\n          }\r\n          item = getParent(item); // drag target should be a top element\r\n          if (!item) {\r\n            return;\r\n          }\r\n        }\r\n        var source = getParent(item);\r\n        if (!source) {\r\n          return;\r\n        }\r\n        if (o.invalid(item, handle)) {\r\n          return;\r\n        }\r\n\r\n        var movable = o.moves(item, source, handle, nextEl(item));\r\n        if (!movable) {\r\n          return;\r\n        }\r\n\r\n        return {\r\n          item: item,\r\n          source: source\r\n        };\r\n      }\r\n\r\n      function canMove (item) {\r\n        return !!canStart(item);\r\n      }\r\n\r\n      function manualStart (item) {\r\n        var context = canStart(item);\r\n        if (context) {\r\n          start(context);\r\n        }\r\n      }\r\n\r\n      function start (context) {\r\n        if (isCopy(context.item, context.source)) {\r\n          _copy = context.item.cloneNode(true);\r\n          drake.emit('cloned', _copy, context.item, 'copy');\r\n        }\r\n\r\n        _source = context.source;\r\n        _item = context.item;\r\n        _initialSibling = _currentSibling = nextEl(context.item);\r\n\r\n        drake.dragging = true;\r\n        drake.emit('drag', _item, _source);\r\n      }\r\n\r\n      function invalidTarget () {\r\n        return false;\r\n      }\r\n\r\n      function end () {\r\n        if (!drake.dragging) {\r\n          return;\r\n        }\r\n        var item = _copy || _item;\r\n        drop(item, getParent(item));\r\n      }\r\n\r\n      function ungrab () {\r\n        _grabbed = false;\r\n        eventualMovements(true);\r\n        movements(true);\r\n      }\r\n\r\n      function release (e) {\r\n        ungrab();\r\n\r\n        if (!drake.dragging) {\r\n          return;\r\n        }\r\n        var item = _copy || _item;\r\n        var clientX = getCoord('clientX', e);\r\n        var clientY = getCoord('clientY', e);\r\n        var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);\r\n        var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);\r\n        if (dropTarget && ((_copy && o.copySortSource) || (!_copy || dropTarget !== _source))) {\r\n          drop(item, dropTarget);\r\n        } else if (o.removeOnSpill) {\r\n          remove();\r\n        } else {\r\n          cancel();\r\n        }\r\n      }\r\n\r\n      function drop (item, target) {\r\n        var parent = getParent(item);\r\n        if (_copy && o.copySortSource && target === _source) {\r\n          parent.removeChild(_item);\r\n        }\r\n        if (isInitialPlacement(target)) {\r\n          drake.emit('cancel', item, _source, _source);\r\n        } else {\r\n          drake.emit('drop', item, target, _source, _currentSibling);\r\n        }\r\n        cleanup();\r\n      }\r\n\r\n      function remove () {\r\n        if (!drake.dragging) {\r\n          return;\r\n        }\r\n        var item = _copy || _item;\r\n        var parent = getParent(item);\r\n        if (parent) {\r\n          parent.removeChild(item);\r\n        }\r\n        drake.emit(_copy ? 'cancel' : 'remove', item, parent, _source);\r\n        cleanup();\r\n      }\r\n\r\n      function cancel (revert) {\r\n        if (!drake.dragging) {\r\n          return;\r\n        }\r\n        var reverts = arguments.length > 0 ? revert : o.revertOnSpill;\r\n        var item = _copy || _item;\r\n        var parent = getParent(item);\r\n        var initial = isInitialPlacement(parent);\r\n        if (initial === false && reverts) {\r\n          if (_copy) {\r\n            if (parent) {\r\n              parent.removeChild(_copy);\r\n            }\r\n          } else {\r\n            _source.insertBefore(item, _initialSibling);\r\n          }\r\n        }\r\n        if (initial || reverts) {\r\n          drake.emit('cancel', item, _source, _source);\r\n        } else {\r\n          drake.emit('drop', item, parent, _source, _currentSibling);\r\n        }\r\n        cleanup();\r\n      }\r\n\r\n      function cleanup () {\r\n        var item = _copy || _item;\r\n        ungrab();\r\n        removeMirrorImage();\r\n        if (item) {\r\n          classes.rm(item, 'gu-transit');\r\n        }\r\n        if (_renderTimer) {\r\n          clearTimeout(_renderTimer);\r\n        }\r\n        drake.dragging = false;\r\n        if (_lastDropTarget) {\r\n          drake.emit('out', item, _lastDropTarget, _source);\r\n        }\r\n        drake.emit('dragend', item);\r\n        _source = _item = _copy = _initialSibling = _currentSibling = _renderTimer = _lastDropTarget = null;\r\n      }\r\n\r\n      function isInitialPlacement (target, s) {\r\n        var sibling;\r\n        if (s !== void 0) {\r\n          sibling = s;\r\n        } else if (_mirror) {\r\n          sibling = _currentSibling;\r\n        } else {\r\n          sibling = nextEl(_copy || _item);\r\n        }\r\n        return target === _source && sibling === _initialSibling;\r\n      }\r\n\r\n      function findDropTarget (elementBehindCursor, clientX, clientY) {\r\n        var target = elementBehindCursor;\r\n        while (target && !accepted()) {\r\n          target = getParent(target);\r\n        }\r\n        return target;\r\n\r\n        function accepted () {\r\n          var droppable = isContainer(target);\r\n          if (droppable === false) {\r\n            return false;\r\n          }\r\n\r\n          var immediate = getImmediateChild(target, elementBehindCursor);\r\n          var reference = getReference(target, immediate, clientX, clientY);\r\n          var initial = isInitialPlacement(target, reference);\r\n          if (initial) {\r\n            return true; // should always be able to drop it right back where it was\r\n          }\r\n          return o.accepts(_item, target, _source, reference);\r\n        }\r\n      }\r\n\r\n      function drag (e) {\r\n        if (!_mirror) {\r\n          return;\r\n        }\r\n        e.preventDefault();\r\n\r\n        var clientX = getCoord('clientX', e);\r\n        var clientY = getCoord('clientY', e);\r\n        var x = clientX - _offsetX;\r\n        var y = clientY - _offsetY;\r\n\r\n        _mirror.style.left = x + 'px';\r\n        _mirror.style.top = y + 'px';\r\n\r\n        var item = _copy || _item;\r\n        var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);\r\n        var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);\r\n        var changed = dropTarget !== null && dropTarget !== _lastDropTarget;\r\n        if (changed || dropTarget === null) {\r\n          out();\r\n          _lastDropTarget = dropTarget;\r\n          over();\r\n        }\r\n        var parent = getParent(item);\r\n        if (dropTarget === _source && _copy && !o.copySortSource) {\r\n          if (parent) {\r\n            parent.removeChild(item);\r\n          }\r\n          return;\r\n        }\r\n        var reference;\r\n        var immediate = getImmediateChild(dropTarget, elementBehindCursor);\r\n        if (immediate !== null) {\r\n          reference = getReference(dropTarget, immediate, clientX, clientY);\r\n        } else if (o.revertOnSpill === true && !_copy) {\r\n          reference = _initialSibling;\r\n          dropTarget = _source;\r\n        } else {\r\n          if (_copy && parent) {\r\n            parent.removeChild(item);\r\n          }\r\n          return;\r\n        }\r\n        if (\r\n          (reference === null && changed) ||\r\n          reference !== item &&\r\n          reference !== nextEl(item)\r\n        ) {\r\n          _currentSibling = reference;\r\n          dropTarget.insertBefore(item, reference);\r\n          drake.emit('shadow', item, dropTarget, _source);\r\n        }\r\n        function moved (type) { drake.emit(type, item, _lastDropTarget, _source); }\r\n        function over () { if (changed) { moved('over'); } }\r\n        function out () { if (_lastDropTarget) { moved('out'); } }\r\n      }\r\n\r\n      function spillOver (el) {\r\n        classes.rm(el, 'gu-hide');\r\n      }\r\n\r\n      function spillOut (el) {\r\n        if (drake.dragging) { classes.add(el, 'gu-hide'); }\r\n      }\r\n\r\n      function renderMirrorImage () {\r\n        if (_mirror) {\r\n          return;\r\n        }\r\n        var rect = _item.getBoundingClientRect();\r\n        _mirror = _item.cloneNode(true);\r\n        _mirror.style.width = getRectWidth(rect) + 'px';\r\n        _mirror.style.height = getRectHeight(rect) + 'px';\r\n        classes.rm(_mirror, 'gu-transit');\r\n        classes.add(_mirror, 'gu-mirror');\r\n        o.mirrorContainer.appendChild(_mirror);\r\n        touchy(documentElement, 'add', 'mousemove', drag);\r\n        classes.add(o.mirrorContainer, 'gu-unselectable');\r\n        drake.emit('cloned', _mirror, _item, 'mirror');\r\n      }\r\n\r\n      function removeMirrorImage () {\r\n        if (_mirror) {\r\n          classes.rm(o.mirrorContainer, 'gu-unselectable');\r\n          touchy(documentElement, 'remove', 'mousemove', drag);\r\n          getParent(_mirror).removeChild(_mirror);\r\n          _mirror = null;\r\n        }\r\n      }\r\n\r\n      function getImmediateChild (dropTarget, target) {\r\n        var immediate = target;\r\n        while (immediate !== dropTarget && getParent(immediate) !== dropTarget) {\r\n          immediate = getParent(immediate);\r\n        }\r\n        if (immediate === documentElement) {\r\n          return null;\r\n        }\r\n        return immediate;\r\n      }\r\n\r\n      function getReference (dropTarget, target, x, y) {\r\n        var horizontal = o.direction === 'horizontal';\r\n        var reference = target !== dropTarget ? inside() : outside();\r\n        return reference;\r\n\r\n        function outside () { // slower, but able to figure out any position\r\n          var len = dropTarget.children.length;\r\n          var i;\r\n          var el;\r\n          var rect;\r\n          for (i = 0; i < len; i++) {\r\n            el = dropTarget.children[i];\r\n            rect = el.getBoundingClientRect();\r\n            if (horizontal && (rect.left + rect.width / 2) > x) { return el; }\r\n            if (!horizontal && (rect.top + rect.height / 2) > y) { return el; }\r\n          }\r\n          return null;\r\n        }\r\n\r\n        function inside () { // faster, but only available if dropped inside a child element\r\n          var rect = target.getBoundingClientRect();\r\n          if (horizontal) {\r\n            return resolve(x > rect.left + getRectWidth(rect) / 2);\r\n          }\r\n          return resolve(y > rect.top + getRectHeight(rect) / 2);\r\n        }\r\n\r\n        function resolve (after) {\r\n          return after ? nextEl(target) : target;\r\n        }\r\n      }\r\n\r\n      function isCopy (item, container) {\r\n        return typeof o.copy === 'boolean' ? o.copy : o.copy(item, container);\r\n      }\r\n    }\r\n\r\n    function touchy (el, op, type, fn) {\r\n      var touch = {\r\n        mouseup: 'touchend',\r\n        mousedown: 'touchstart',\r\n        mousemove: 'touchmove'\r\n      };\r\n      var pointers = {\r\n        mouseup: 'pointerup',\r\n        mousedown: 'pointerdown',\r\n        mousemove: 'pointermove'\r\n      };\r\n      var microsoft = {\r\n        mouseup: 'MSPointerUp',\r\n        mousedown: 'MSPointerDown',\r\n        mousemove: 'MSPointerMove'\r\n      };\r\n      if (global.navigator.pointerEnabled) {\r\n        crossvent[op](el, pointers[type], fn);\r\n      } else if (global.navigator.msPointerEnabled) {\r\n        crossvent[op](el, microsoft[type], fn);\r\n      } else {\r\n        crossvent[op](el, touch[type], fn);\r\n        crossvent[op](el, type, fn);\r\n      }\r\n    }\r\n\r\n    function whichMouseButton (e) {\r\n      if (e.touches !== void 0) { return e.touches.length; }\r\n      if (e.which !== void 0 && e.which !== 0) { return e.which; } // see https://github.com/bevacqua/dragula/issues/261\r\n      if (e.buttons !== void 0) { return e.buttons; }\r\n      var button = e.button;\r\n      if (button !== void 0) { // see https://github.com/jquery/jquery/blob/99e8ff1baa7ae341e94bb89c3e84570c7c3ad9ea/src/event.js#L573-L575\r\n        return button & 1 ? 1 : button & 2 ? 3 : (button & 4 ? 2 : 0);\r\n      }\r\n    }\r\n\r\n    function getOffset (el) {\r\n      var rect = el.getBoundingClientRect();\r\n      return {\r\n        left: rect.left + getScroll('scrollLeft', 'pageXOffset'),\r\n        top: rect.top + getScroll('scrollTop', 'pageYOffset')\r\n      };\r\n    }\r\n\r\n    function getScroll (scrollProp, offsetProp) {\r\n      if (typeof global[offsetProp] !== 'undefined') {\r\n        return global[offsetProp];\r\n      }\r\n      if (documentElement.clientHeight) {\r\n        return documentElement[scrollProp];\r\n      }\r\n      return doc.body[scrollProp];\r\n    }\r\n\r\n    function getElementBehindPoint (point, x, y) {\r\n      var p = point || {};\r\n      var state = p.className;\r\n      var el;\r\n      p.className += ' gu-hide';\r\n      el = doc.elementFromPoint(x, y);\r\n      p.className = state;\r\n      return el;\r\n    }\r\n\r\n    function never () { return false; }\r\n    function always () { return true; }\r\n    function getRectWidth (rect) { return rect.width || (rect.right - rect.left); }\r\n    function getRectHeight (rect) { return rect.height || (rect.bottom - rect.top); }\r\n    function getParent (el) { return el.parentNode === doc ? null : el.parentNode; }\r\n    function isInput (el) { return el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.tagName === 'SELECT' || isEditable(el); }\r\n    function isEditable (el) {\r\n      if (!el) { return false; } // no parents were editable\r\n      if (el.contentEditable === 'false') { return false; } // stop the lookup\r\n      if (el.contentEditable === 'true') { return true; } // found a contentEditable element in the chain\r\n      return isEditable(getParent(el)); // contentEditable is set to 'inherit'\r\n    }\r\n\r\n    function nextEl (el) {\r\n      return el.nextElementSibling || manually();\r\n      function manually () {\r\n        var sibling = el;\r\n        do {\r\n          sibling = sibling.nextSibling;\r\n        } while (sibling && sibling.nodeType !== 1);\r\n        return sibling;\r\n      }\r\n    }\r\n\r\n    function getEventHost (e) {\r\n      // on touchend event, we have to use `e.changedTouches`\r\n      // see http://stackoverflow.com/questions/7192563/touchend-event-properties\r\n      // see https://github.com/bevacqua/dragula/issues/34\r\n      if (e.targetTouches && e.targetTouches.length) {\r\n        return e.targetTouches[0];\r\n      }\r\n      if (e.changedTouches && e.changedTouches.length) {\r\n        return e.changedTouches[0];\r\n      }\r\n      return e;\r\n    }\r\n\r\n    function getCoord (coord, e) {\r\n      var host = getEventHost(e);\r\n      var missMap = {\r\n        pageX: 'clientX', // IE8\r\n        pageY: 'clientY' // IE8\r\n      };\r\n      if (coord in missMap && !(coord in host) && missMap[coord] in host) {\r\n        coord = missMap[coord];\r\n      }\r\n      return host[coord];\r\n    }\r\n\r\n    return skylark.dragula = dragula;\r\n\r\n});\r\n"]}