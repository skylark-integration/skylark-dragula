{"version":3,"sources":["dragula.js"],"names":["define","skylark","mouse","touch","noder","finder","geom","eventer","emitter","crossvent","classes","doc","window","document","documentElement","touchy","el","op","type","fn","on","off","touchInited","mousy","whichMouseButton","e","touches","length","which","buttons","button","getElementBehindPoint","point","x","y","elementFromPoint","never","always","getRectWidth","rect","width","right","left","getRectHeight","height","bottom","top","getParent","parent","isInput","nextEl","nextSibling","getCoord","coord","host","targetTouches","changedTouches","getEventHost","missMap","pageX","pageY","attach","initialContainers","options","_mirror","_source","_item","_offsetX","_offsetY","_moveX","_moveY","_initialSibling","_currentSibling","_copy","_renderTimer","arguments","Array","isArray","_grabbed","_lastDropTarget","o","moves","accepts","invalid","containers","isContainer","copy","copySortSource","revertOnSpill","removeOnSpill","direction","ignoreInputTextSelection","mirrorContainer","body","drake","start","item","context","canStart","end","cancel","remove","destroy","events","release","canMove","dragging","rm","add","indexOf","grab","eventualMovements","startBecauseMouseMoved","movements","preventGrabbed","preventDefault","clientX","clientY","metaKey","ctrlKey","target","focus","fromPoint","grabbed","offset","pagePosition","getBoundingClientRect","cloneNode","style","appendChild","drag","emit","renderMirrorImage","handle","source","container","drop","ungrab","dropTarget","findDropTarget","removeChild","isInitialPlacement","cleanup","revert","reverts","initial","insertBefore","clearTimeout","s","sibling","elementBehindCursor","accepted","immediate","getImmediateChild","reference","getReference","changed","moved","horizontal","boundingRect","resolve","i","len","children","outside","after"],"mappings":";;;;;;;AAAAA,QACE,wBACA,+BACA,+BACA,qBACA,sBACA,oBACA,uBACA,YACA,cACA,aACA,SACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,GAGE,aACA,IAEIC,EAFSC,OAEIC,SACbC,EAAkBH,EAAIG,gBA+e1B,SAASC,EAAQC,EAAIC,EAAIC,EAAMC,GA0BnB,OAANF,EACFV,EAAQa,GAAGJ,EAAGE,EAAKC,GAEnBZ,EAAQc,IAAIL,EAAGE,EAAKC,GAGjBH,EAAGM,cACNN,EAAGM,aAAc,EACjBnB,EAAMoB,MAAMP,IAMhB,SAASQ,EAAkBC,GAEzB,QAAkB,IAAdA,EAAEC,QAAsB,OAAOD,EAAEC,QAAQC,OAC7C,QAAgB,IAAZF,EAAEG,OAAgC,IAAZH,EAAEG,MAAe,OAAOH,EAAEG,MACpD,QAAkB,IAAdH,EAAEI,QAAsB,OAAOJ,EAAEI,QACrC,IAAIC,EAASL,EAAEK,OACf,YAAe,IAAXA,EACc,EAATA,EAAa,EAAa,EAATA,EAAa,EAAc,EAATA,EAAa,EAAI,OAD7D,EA6BF,SAASC,EAAuBC,EAAOC,EAAGC,GAOxC,OAFKvB,EAAIwB,iBAAiBF,EAAGC,GAK/B,SAASE,IACP,OAAO,EAET,SAASC,IACP,OAAO,EAET,SAASC,EAAcC,GACrB,OAAOA,EAAKC,OAAUD,EAAKE,MAAQF,EAAKG,KAE1C,SAASC,EAAeJ,GACtB,OAAOA,EAAKK,QAAWL,EAAKM,OAASN,EAAKO,IAE5C,SAASC,EAAW/B,GAElB,OAAOX,EAAO2C,OAAOhC,GAEvB,SAASiC,EAASjC,GAEhB,OAAOZ,EAAM6C,QAAQjC,GAevB,SAASkC,EAAQlC,GAWf,OAAOX,EAAO8C,YAAYnC,GAgB5B,SAASoC,EAAUC,EAAO5B,GACxB,IAAI6B,EAdN,SAAuB7B,GAIrB,OAAIA,EAAE8B,eAAiB9B,EAAE8B,cAAc5B,OAC9BF,EAAE8B,cAAc,GAErB9B,EAAE+B,gBAAkB/B,EAAE+B,eAAe7B,OAChCF,EAAE+B,eAAe,GAEnB/B,EAIIgC,CAAahC,GACpBiC,GACFC,MAAO,UACPC,MAAO,WAKT,OAHIP,KAASK,KAAaL,KAASC,IAASI,EAAQL,KAAUC,IAC5DD,EAAQK,EAAQL,IAEXC,EAAKD,GAGd,OAAOpD,EAAQ4D,OAAO,eA1oBtB,SAAkBC,EAAmBC,GACnC,IAKIC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAdQ,IADFC,UAAUhD,SACkC,IAArCiD,MAAMC,QAAQf,KAC7BC,EAAUD,EACVA,MAaF,IACIgB,EADAC,EAAkB,KAGlBC,EAAIjB,WACQ,IAAZiB,EAAEC,QAAoBD,EAAEC,MAAQ5C,QAClB,IAAd2C,EAAEE,UAAsBF,EAAEE,QAAU7C,QACtB,IAAd2C,EAAEG,UAAsBH,EAAEG,QAwL9B,WACE,OAAO,SAxLY,IAAjBH,EAAEI,aAAyBJ,EAAEI,WAAatB,YACxB,IAAlBkB,EAAEK,cAA0BL,EAAEK,YAAcjD,QACjC,IAAX4C,EAAEM,OAAmBN,EAAEM,MAAO,QACT,IAArBN,EAAEO,iBAA6BP,EAAEO,gBAAiB,QAC9B,IAApBP,EAAEQ,gBAA4BR,EAAEQ,eAAgB,QAC5B,IAApBR,EAAES,gBAA4BT,EAAES,eAAgB,QAChC,IAAhBT,EAAEU,YAAwBV,EAAEU,UAAY,iBACT,IAA/BV,EAAEW,2BAAuCX,EAAEW,0BAA2B,QAChD,IAAtBX,EAAEY,kBAA8BZ,EAAEY,gBAAkBjF,EAAIkF,MAE5D,IAAIC,EAAQtF,GACV4E,WAAYJ,EAAEI,WACdW,MAsJF,SAAsBC,GACpB,IAAIC,EAAUC,EAASF,GACnBC,GACFF,EAAME,IAxJRE,IAAKA,EACLC,OAAQA,EACRC,OAAQA,EACRC,QAkCF,WACEC,GAAO,GACPC,OAnCAC,QA6IF,SAAkBT,GAChB,QAASE,EAASF,IA7IlBU,UAAU,IASZ,OANwB,IAApB1B,EAAES,eACJK,EAAM1E,GAAG,OAwWX,SAAoBJ,GAClBN,EAAQiG,GAAG3F,EAAI,aAzWaI,GAAG,MA4WjC,SAAmBJ,GACb8E,EAAMY,UAAYhG,EAAQkG,IAAI5F,EAAI,aA1WxCuF,IAEOT,EAEP,SAAST,EAAarE,GACpB,OAAyC,IAAlC8E,EAAMV,WAAWyB,QAAQ7F,IAAcgE,EAAEK,YAAYrE,GAG9D,SAASuF,EAAQF,GACf,IAAIpF,EAAKoF,EAAS,SAAW,MAC7BtF,EAAOD,EAAiBG,EAAI,YAAa6F,GACzC/F,EAAOD,EAAiBG,EAAI,UAAWuF,GAGzC,SAASO,EAAmBV,GAE1BtF,EAAOD,EADEuF,EAAS,SAAW,MACD,YAAaW,GAG3C,SAASC,EAAWZ,GAClB,IAAIpF,EAAKoF,EAAS,SAAW,MAC7B5F,EAAUQ,GAAIH,EAAiB,cAAeoG,GAC9CzG,EAAUQ,GAAIH,EAAiB,QAASoG,GAQ1C,SAASA,EAAgBzF,GACnBqD,GACFrD,EAAE0F,iBAIN,SAASL,EAAMrF,GAKb,GAJA4C,EAAS5C,EAAE2F,QACX9C,EAAS7C,EAAE4F,QAE0B,IAAxB7F,EAAiBC,KAAYA,EAAE6F,UAAW7F,EAAE8F,QACzD,CAGA,IAAIvB,EAAOvE,EAAE+F,OACTvB,EAAUC,EAASF,GAClBC,IAGLnB,EAAWmB,EACXc,IACe,cAAXtF,EAAEP,OACA+B,EAAQ+C,GACVA,EAAKyB,QAELhG,EAAE0F,oBAKR,SAASH,EAAwBvF,GAC/B,GAAKqD,EAGL,GAA4B,IAAxBtD,EAAiBC,IAKrB,QAAkB,IAAdA,EAAE2F,SAAsB3F,EAAE2F,UAAY/C,QAAwB,IAAd5C,EAAE4F,SAAsB5F,EAAE4F,UAAY/C,EAA1F,CAGA,GAAIU,EAAEW,yBAA0B,CAC9B,IAAIyB,EAAUhE,EAAS,UAAW3B,GAC9B4F,EAAUjE,EAAS,UAAW3B,GAGlC,GAAIwB,EADsB7C,EAAMsH,UAAUN,EAAQC,IAEhD,OAIJ,IAAIM,EAAU7C,EACdiC,GAAkB,GAClBE,IACAd,IACAJ,EAAM4B,GAEN,IAwZgB3G,EAxZZ4G,GAwZY5G,EAxZOkD,EAgalB5D,EAAKuH,aAAa7G,IA/ZvBmD,EAAWf,EAAS,QAAS3B,GAAKmG,EAAOlF,KACzC0B,EAAWhB,EAAS,QAAS3B,GAAKmG,EAAO9E,IAEzCpC,EAAQkG,IAAInC,GAASP,EAAO,cAiR9B,WACE,IAAIF,EAAJ,CAGA,IAAIzB,EAAO2B,EAAM4D,yBACjB9D,EAAUE,EAAM6D,WAAU,IAClBC,MAAMxF,MAAQF,EAAaC,GAAQ,KAC3CyB,EAAQgE,MAAMpF,OAASD,EAAcJ,GAAQ,KAC7C7B,EAAQiG,GAAG3C,EAAS,cACpBtD,EAAQkG,IAAI5C,EAAS,aACrBgB,EAAEY,gBAAgBqC,YAAYjE,GAC9BjD,EAAOD,EAAiB,MAAO,YAAaoH,GAC5CxH,EAAQkG,IAAI5B,EAAEY,gBAAiB,mBAC/BE,EAAMqC,KAAK,SAAUnE,EAASE,EAAO,WA7RrCkE,GACAF,EAAKzG,SA7BH+E,MAgCJ,SAASN,EAAUF,GACjB,KAAIF,EAAMY,UAAY1C,GAGlBqB,EAAYW,IAAhB,CAIA,IADA,IAAIqC,EAASrC,EACNjD,EAAUiD,KAA0C,IAAjCX,EAAYtC,EAAUiD,KAAkB,CAChE,GAAIhB,EAAEG,QAAQa,EAAMqC,GAClB,OAGF,KADArC,EAAOjD,EAAUiD,IAEf,OAGJ,IAAIsC,EAASvF,EAAUiD,GACvB,GAAKsC,IAGDtD,EAAEG,QAAQa,EAAMqC,IAINrD,EAAEC,MAAMe,EAAMsC,EAAQD,EAAQnF,EAAO8C,IAKnD,OACEA,KAAMA,EACNsC,OAAQA,IAeZ,SAASvC,EAAOE,GAqShB,IAAiBD,EAAMuC,EAANvC,EApSJC,EAAQD,KAoSEuC,EApSItC,EAAQqC,QAqSR,kBAAXtD,EAAEM,KAAqBN,EAAEM,KAAON,EAAEM,KAAKU,EAAMuC,MApSzD9D,EAAQwB,EAAQD,KAAK+B,WAAU,GAC/BjC,EAAMqC,KAAK,SAAU1D,EAAOwB,EAAQD,KAAM,SAG5C/B,EAAUgC,EAAQqC,OAClBpE,EAAQ+B,EAAQD,KAChBzB,EAAkBC,EAAkBtB,EAAO+C,EAAQD,MAEnDF,EAAMY,UAAW,EACjBZ,EAAMqC,KAAK,OAAQjE,EAAOD,GAO5B,SAASkC,IACP,GAAKL,EAAMY,SAAX,CAGA,IAAIV,EAAOvB,GAASP,EACpBsE,EAAKxC,EAAMjD,EAAUiD,KAGvB,SAASyC,IACP3D,GAAW,EACXiC,GAAkB,GAClBE,GAAU,GAGZ,SAAST,EAAS/E,GAGhB,GAFAgH,IAEK3C,EAAMY,SAAX,CAGA,IAAIV,EAAOvB,GAASP,EAChBkD,EAAUhE,EAAS,UAAW3B,GAC9B4F,EAAUjE,EAAS,UAAW3B,GAE9BiH,EAAaC,EADS5G,EAAsBiC,EAASoD,EAASC,GACbD,EAASC,GAC1DqB,IAAgBjE,GAASO,EAAEO,iBAAqBd,GAASiE,IAAezE,GAC1EuE,EAAKxC,EAAM0C,GACF1D,EAAES,cACXY,IAEAD,KAIJ,SAASoC,EAAMxC,EAAMwB,GACnB,IAAIxE,EAASD,EAAUiD,GACnBvB,GAASO,EAAEO,gBAAkBiC,IAAWvD,GAC1CjB,EAAO4F,YAAY1E,GAEjB2E,EAAmBrB,GACrB1B,EAAMqC,KAAK,SAAUnC,EAAM/B,EAASA,GAEpC6B,EAAMqC,KAAK,OAAQnC,EAAMwB,EAAQvD,EAASO,GAE5CsE,IAGF,SAASzC,IACP,GAAKP,EAAMY,SAAX,CAGA,IAAIV,EAAOvB,GAASP,EAChBlB,EAASD,EAAUiD,GACnBhD,GACFA,EAAO4F,YAAY5C,GAErBF,EAAMqC,KAAK1D,EAAQ,SAAW,SAAUuB,EAAMhD,EAAQiB,GACtD6E,KAGF,SAAS1C,EAAQ2C,GACf,GAAKjD,EAAMY,SAAX,CAGA,IAAIsC,EAAUrE,UAAUhD,OAAS,EAAIoH,EAAS/D,EAAEQ,cAC5CQ,EAAOvB,GAASP,EAChBlB,EAASD,EAAUiD,GACnBiD,EAAUJ,EAAmB7F,IACjB,IAAZiG,GAAqBD,IACnBvE,EACEzB,GACFA,EAAO4F,YAAYnE,GAGrBR,EAAQiF,aAAalD,EAAMzB,IAG3B0E,GAAWD,EACblD,EAAMqC,KAAK,SAAUnC,EAAM/B,EAASA,GAEpC6B,EAAMqC,KAAK,OAAQnC,EAAMhD,EAAQiB,EAASO,GAE5CsE,KAGF,SAASA,IACP,IAAI9C,EAAOvB,GAASP,EACpBuE,IAqIIzE,IACFtD,EAAQiG,GAAG3B,EAAEY,gBAAiB,mBAC9B7E,EAAOD,EAAiB,SAAU,YAAaoH,GAC/CnF,EAAUiB,GAAS4E,YAAY5E,GAC/BA,EAAU,MAvIRgC,GACFtF,EAAQiG,GAAGX,EAAM,cAEftB,GACFyE,aAAazE,GAEfoB,EAAMY,UAAW,EACb3B,GACFe,EAAMqC,KAAK,MAAOnC,EAAMjB,EAAiBd,GAE3C6B,EAAMqC,KAAK,UAAWnC,GACtB/B,EAAUC,EAAQO,EAAQF,EAAkBC,EAAkBE,EAAeK,EAAkB,KAGjG,SAAS8D,EAAoBrB,EAAQ4B,GACnC,IAAIC,EAQJ,OANEA,OADQ,IAAND,EACQA,EACDpF,EACCQ,EAEAtB,EAAOuB,GAASP,GAErBsD,IAAWvD,GAAWoF,IAAY9E,EAG3C,SAASoE,EAAgBW,EAAqBlC,EAASC,GAErD,IADA,IAAIG,EAAS8B,EACN9B,IAAW+B,KAChB/B,EAASzE,EAAUyE,GAErB,OAAOA,EAEP,SAAS+B,IAEP,IAAkB,IADFlE,EAAYmC,GAE1B,OAAO,EAGT,IAAIgC,EAAYC,GAAkBjC,EAAQ8B,GACtCI,EAAYC,GAAanC,EAAQgC,EAAWpC,EAASC,GAEzD,QADcwB,EAAmBrB,EAAQkC,IAIlC1E,EAAEE,QAAQhB,EAAOsD,EAAQvD,EAASyF,IAI7C,SAASxB,EAAMzG,GACb,GAAKuC,EAAL,CAGAvC,EAAE0F,iBAEF,IAAIC,EAAUhE,EAAS,UAAW3B,GAC9B4F,EAAUjE,EAAS,UAAW3B,GAC9BQ,EAAImF,EAAUjD,EACdjC,EAAImF,EAAUjD,EAElBJ,EAAQgE,MAAMtF,KAAOT,EAAI,KACzB+B,EAAQgE,MAAMlF,IAAMZ,EAAI,KAExB,IAAI8D,EAAOvB,GAASP,EAChBoF,EAAsBvH,EAAsBiC,EAASoD,EAASC,GAC9DqB,EAAaC,EAAeW,EAAqBlC,EAASC,GAC1DuC,EAAyB,OAAflB,GAAuBA,IAAe3D,GAChD6E,GAA0B,OAAflB,KAoCO3D,GAAmB8E,EAAM,OAlC7C9E,EAAkB2D,EAiCGkB,GAAWC,EAAM,SA9BxC,IAAI7G,EAASD,EAAUiD,GACvB,GAAI0C,IAAezE,IAAWQ,GAAUO,EAAEO,eAA1C,CAMA,IAAImE,EACAF,EAAYC,GAAkBf,EAAYY,GAC9C,GAAkB,OAAdE,EACFE,EAAYC,GAAajB,EAAYc,EAAWpC,EAASC,OACpD,CAAA,IAAwB,IAApBrC,EAAEQ,eAA2Bf,EAOtC,YAHIA,GAASzB,GACXA,EAAO4F,YAAY5C,IAJrB0D,EAAYnF,EACZmE,EAAazE,GAQE,OAAdyF,GAAsBE,GACvBF,IAAc1D,GACd0D,IAAcxG,EAAO8C,MAErBxB,EAAkBkF,EAClBhB,EAAWQ,aAAalD,EAAM0D,GAC9B5D,EAAMqC,KAAK,SAAUnC,EAAM0C,EAAYzE,SAzBnCjB,GACFA,EAAO4F,YAAY5C,GA0BvB,SAAS6D,EAAO3I,GAAQ4E,EAAMqC,KAAKjH,EAAM8E,EAAMjB,EAAiBd,IAsClE,SAASwF,GAAmBf,EAAYlB,GAEtC,IADA,IAAIgC,EAAYhC,EACTgC,IAAcd,GAAc3F,EAAUyG,KAAed,GAC1Dc,EAAYzG,EAAUyG,GAExB,OAAIA,IAAc1I,EACT,KAEF0I,EAGT,SAASG,GAAcjB,EAAYlB,EAAQvF,EAAGC,GAC5C,IAsBOK,EAtBHuH,EAA6B,eAAhB9E,EAAEU,UAEnB,OADgB8B,IAAWkB,GAqBpBnG,EAAOjC,EAAKyJ,aAAavC,GAErBwC,EADLF,EACa7H,EAAIM,EAAKG,KAAOJ,EAAaC,GAAQ,EAEvCL,EAAIK,EAAKO,IAAMH,EAAcJ,GAAQ,IAtBtD,WACE,IACI0H,EACAjJ,EACAuB,EAHA2H,EAAMxB,EAAWyB,SAASxI,OAI9B,IAAKsI,EAAI,EAAGA,EAAIC,EAAKD,IAAK,CAIxB,GAHAjJ,EAAK0H,EAAWyB,SAASF,GAEzB1H,EAAOjC,EAAKyJ,aAAa/I,GACrB8I,GAAevH,EAAKG,KAAOH,EAAKC,MAAQ,EAAKP,EAAK,OAAOjB,EAC7D,IAAK8I,GAAevH,EAAKO,IAAMP,EAAKK,OAAS,EAAKV,EAAK,OAAOlB,EAEhE,OAAO,KAf0CoJ,GA6BnD,SAASJ,EAASK,GAChB,OAAOA,EAAQnH,EAAOsE,GAAUA","file":"../dragula.js","sourcesContent":["define([\r\n  \"skylark-langx/skylark\",\r\n  \"skylark-devices-points/mouse\",\r\n  \"skylark-devices-points/touch\",\r\n  \"skylark-domx-noder\",\r\n  \"skylark-domx-finder\",\r\n  \"skylark-domx-geom\",\r\n  \"skylark-domx-eventer\",\r\n  \"./emitter\",\r\n  \"./crossvent\",\r\n  \"./classes\"\r\n],function(\r\n  skylark,\r\n  mouse,\r\n  touch,\r\n  noder,\r\n  finder,\r\n  geom,\r\n  eventer,\r\n  emitter,\r\n  crossvent,\r\n  classes\r\n){\r\n\r\n    'use strict';\r\n    var global = window;\r\n\r\n    var doc = global.document;\r\n    var documentElement = doc.documentElement;\r\n\r\n    function dragula (initialContainers, options) {\r\n      var len = arguments.length;\r\n      if (len === 1 && Array.isArray(initialContainers) === false) {\r\n        options = initialContainers;\r\n        initialContainers = [];\r\n      }\r\n      var _mirror; // mirror image\r\n      var _source; // source container\r\n      var _item; // item being dragged\r\n      var _offsetX; // reference x\r\n      var _offsetY; // reference y\r\n      var _moveX; // reference move x\r\n      var _moveY; // reference move y\r\n      var _initialSibling; // reference sibling when grabbed\r\n      var _currentSibling; // reference sibling now\r\n      var _copy; // item used for copying\r\n      var _renderTimer; // timer for setTimeout renderMirrorImage\r\n      var _lastDropTarget = null; // last container item was over\r\n      var _grabbed; // holds mousedown context until first mousemove\r\n\r\n      var o = options || {};\r\n      if (o.moves === void 0) { o.moves = always; }\r\n      if (o.accepts === void 0) { o.accepts = always; }\r\n      if (o.invalid === void 0) { o.invalid = invalidTarget; }\r\n      if (o.containers === void 0) { o.containers = initialContainers || []; }\r\n      if (o.isContainer === void 0) { o.isContainer = never; }\r\n      if (o.copy === void 0) { o.copy = false; }\r\n      if (o.copySortSource === void 0) { o.copySortSource = false; }\r\n      if (o.revertOnSpill === void 0) { o.revertOnSpill = false; }\r\n      if (o.removeOnSpill === void 0) { o.removeOnSpill = false; }\r\n      if (o.direction === void 0) { o.direction = 'vertical'; }\r\n      if (o.ignoreInputTextSelection === void 0) { o.ignoreInputTextSelection = true; }\r\n      if (o.mirrorContainer === void 0) { o.mirrorContainer = doc.body; }\r\n\r\n      var drake = emitter({\r\n        containers: o.containers,\r\n        start: manualStart,\r\n        end: end,\r\n        cancel: cancel,\r\n        remove: remove,\r\n        destroy: destroy,\r\n        canMove: canMove,\r\n        dragging: false\r\n      });\r\n\r\n      if (o.removeOnSpill === true) {\r\n        drake.on('over', spillOver).on('out', spillOut);\r\n      }\r\n\r\n      events();\r\n\r\n      return drake;\r\n\r\n      function isContainer (el) {\r\n        return drake.containers.indexOf(el) !== -1 || o.isContainer(el);\r\n      }\r\n\r\n      function events (remove) {\r\n        var op = remove ? 'remove' : 'add';\r\n        touchy(documentElement, op, 'mousedown', grab);\r\n        touchy(documentElement, op, 'mouseup', release);\r\n      }\r\n\r\n      function eventualMovements (remove) {\r\n        var op = remove ? 'remove' : 'add';\r\n        touchy(documentElement, op, 'mousemove', startBecauseMouseMoved);\r\n      }\r\n\r\n      function movements (remove) {\r\n        var op = remove ? 'remove' : 'add';\r\n        crossvent[op](documentElement, 'selectstart', preventGrabbed); // IE8\r\n        crossvent[op](documentElement, 'click', preventGrabbed);\r\n      }\r\n\r\n      function destroy () {\r\n        events(true);\r\n        release({});\r\n      }\r\n\r\n      function preventGrabbed (e) {\r\n        if (_grabbed) {\r\n          e.preventDefault();\r\n        }\r\n      }\r\n\r\n      function grab (e) {\r\n        _moveX = e.clientX;\r\n        _moveY = e.clientY;\r\n\r\n        var ignore = whichMouseButton(e) !== 1 || e.metaKey || e.ctrlKey;\r\n        if (ignore) {\r\n          return; // we only care about honest-to-god left clicks and touch events\r\n        }\r\n        var item = e.target;\r\n        var context = canStart(item);\r\n        if (!context) {\r\n          return;\r\n        }\r\n        _grabbed = context;\r\n        eventualMovements();\r\n        if (e.type === 'mousedown') {\r\n          if (isInput(item)) { // see also: https://github.com/bevacqua/dragula/issues/208\r\n            item.focus(); // fixes https://github.com/bevacqua/dragula/issues/176\r\n          } else {\r\n            e.preventDefault(); // fixes https://github.com/bevacqua/dragula/issues/155\r\n          }\r\n        }\r\n      }\r\n\r\n      function startBecauseMouseMoved (e) {\r\n        if (!_grabbed) {\r\n          return;\r\n        }\r\n        if (whichMouseButton(e) === 0) {\r\n          release({});\r\n          return; // when text is selected on an input and then dragged, mouseup doesn't fire. this is our only hope\r\n        }\r\n        // truthy check fixes #239, equality fixes #207\r\n        if (e.clientX !== void 0 && e.clientX === _moveX && e.clientY !== void 0 && e.clientY === _moveY) {\r\n          return;\r\n        }\r\n        if (o.ignoreInputTextSelection) {\r\n          var clientX = getCoord('clientX', e);\r\n          var clientY = getCoord('clientY', e);\r\n          //var elementBehindCursor = doc.elementFromPoint(clientX, clientY);\r\n          var elementBehindCursor = noder.fromPoint(clientX,clientY);\r\n          if (isInput(elementBehindCursor)) {\r\n            return;\r\n          }\r\n        }\r\n\r\n        var grabbed = _grabbed; // call to end() unsets _grabbed\r\n        eventualMovements(true);\r\n        movements();\r\n        end();\r\n        start(grabbed);\r\n\r\n        var offset = getOffset(_item);\r\n        _offsetX = getCoord('pageX', e) - offset.left;\r\n        _offsetY = getCoord('pageY', e) - offset.top;\r\n\r\n        classes.add(_copy || _item, 'gu-transit');\r\n        renderMirrorImage();\r\n        drag(e);\r\n      }\r\n\r\n      function canStart (item) {\r\n        if (drake.dragging && _mirror) {\r\n          return;\r\n        }\r\n        if (isContainer(item)) {\r\n          return; // don't drag container itself\r\n        }\r\n        var handle = item;\r\n        while (getParent(item) && isContainer(getParent(item)) === false) {\r\n          if (o.invalid(item, handle)) {\r\n            return;\r\n          }\r\n          item = getParent(item); // drag target should be a top element\r\n          if (!item) {\r\n            return;\r\n          }\r\n        }\r\n        var source = getParent(item);\r\n        if (!source) {\r\n          return;\r\n        }\r\n        if (o.invalid(item, handle)) {\r\n          return;\r\n        }\r\n\r\n        var movable = o.moves(item, source, handle, nextEl(item));\r\n        if (!movable) {\r\n          return;\r\n        }\r\n\r\n        return {\r\n          item: item,\r\n          source: source\r\n        };\r\n      }\r\n\r\n      function canMove (item) {\r\n        return !!canStart(item);\r\n      }\r\n\r\n      function manualStart (item) {\r\n        var context = canStart(item);\r\n        if (context) {\r\n          start(context);\r\n        }\r\n      }\r\n\r\n      function start (context) {\r\n        if (isCopy(context.item, context.source)) {\r\n          _copy = context.item.cloneNode(true);\r\n          drake.emit('cloned', _copy, context.item, 'copy');\r\n        }\r\n\r\n        _source = context.source;\r\n        _item = context.item;\r\n        _initialSibling = _currentSibling = nextEl(context.item);\r\n\r\n        drake.dragging = true;\r\n        drake.emit('drag', _item, _source);\r\n      }\r\n\r\n      function invalidTarget () {\r\n        return false;\r\n      }\r\n\r\n      function end () {\r\n        if (!drake.dragging) {\r\n          return;\r\n        }\r\n        var item = _copy || _item;\r\n        drop(item, getParent(item));\r\n      }\r\n\r\n      function ungrab () {\r\n        _grabbed = false;\r\n        eventualMovements(true);\r\n        movements(true);\r\n      }\r\n\r\n      function release (e) {\r\n        ungrab();\r\n\r\n        if (!drake.dragging) {\r\n          return;\r\n        }\r\n        var item = _copy || _item;\r\n        var clientX = getCoord('clientX', e);\r\n        var clientY = getCoord('clientY', e);\r\n        var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);\r\n        var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);\r\n        if (dropTarget && ((_copy && o.copySortSource) || (!_copy || dropTarget !== _source))) {\r\n          drop(item, dropTarget);\r\n        } else if (o.removeOnSpill) {\r\n          remove();\r\n        } else {\r\n          cancel();\r\n        }\r\n      }\r\n\r\n      function drop (item, target) {\r\n        var parent = getParent(item);\r\n        if (_copy && o.copySortSource && target === _source) {\r\n          parent.removeChild(_item);\r\n        }\r\n        if (isInitialPlacement(target)) {\r\n          drake.emit('cancel', item, _source, _source);\r\n        } else {\r\n          drake.emit('drop', item, target, _source, _currentSibling);\r\n        }\r\n        cleanup();\r\n      }\r\n\r\n      function remove () {\r\n        if (!drake.dragging) {\r\n          return;\r\n        }\r\n        var item = _copy || _item;\r\n        var parent = getParent(item);\r\n        if (parent) {\r\n          parent.removeChild(item);\r\n        }\r\n        drake.emit(_copy ? 'cancel' : 'remove', item, parent, _source);\r\n        cleanup();\r\n      }\r\n\r\n      function cancel (revert) {\r\n        if (!drake.dragging) {\r\n          return;\r\n        }\r\n        var reverts = arguments.length > 0 ? revert : o.revertOnSpill;\r\n        var item = _copy || _item;\r\n        var parent = getParent(item);\r\n        var initial = isInitialPlacement(parent);\r\n        if (initial === false && reverts) {\r\n          if (_copy) {\r\n            if (parent) {\r\n              parent.removeChild(_copy);\r\n            }\r\n          } else {\r\n            _source.insertBefore(item, _initialSibling);\r\n          }\r\n        }\r\n        if (initial || reverts) {\r\n          drake.emit('cancel', item, _source, _source);\r\n        } else {\r\n          drake.emit('drop', item, parent, _source, _currentSibling);\r\n        }\r\n        cleanup();\r\n      }\r\n\r\n      function cleanup () {\r\n        var item = _copy || _item;\r\n        ungrab();\r\n        removeMirrorImage();\r\n        if (item) {\r\n          classes.rm(item, 'gu-transit');\r\n        }\r\n        if (_renderTimer) {\r\n          clearTimeout(_renderTimer);\r\n        }\r\n        drake.dragging = false;\r\n        if (_lastDropTarget) {\r\n          drake.emit('out', item, _lastDropTarget, _source);\r\n        }\r\n        drake.emit('dragend', item);\r\n        _source = _item = _copy = _initialSibling = _currentSibling = _renderTimer = _lastDropTarget = null;\r\n      }\r\n\r\n      function isInitialPlacement (target, s) {\r\n        var sibling;\r\n        if (s !== void 0) {\r\n          sibling = s;\r\n        } else if (_mirror) {\r\n          sibling = _currentSibling;\r\n        } else {\r\n          sibling = nextEl(_copy || _item);\r\n        }\r\n        return target === _source && sibling === _initialSibling;\r\n      }\r\n\r\n      function findDropTarget (elementBehindCursor, clientX, clientY) {\r\n        var target = elementBehindCursor;\r\n        while (target && !accepted()) {\r\n          target = getParent(target);\r\n        }\r\n        return target;\r\n\r\n        function accepted () {\r\n          var droppable = isContainer(target);\r\n          if (droppable === false) {\r\n            return false;\r\n          }\r\n\r\n          var immediate = getImmediateChild(target, elementBehindCursor);\r\n          var reference = getReference(target, immediate, clientX, clientY);\r\n          var initial = isInitialPlacement(target, reference);\r\n          if (initial) {\r\n            return true; // should always be able to drop it right back where it was\r\n          }\r\n          return o.accepts(_item, target, _source, reference);\r\n        }\r\n      }\r\n\r\n      function drag (e) {\r\n        if (!_mirror) {\r\n          return;\r\n        }\r\n        e.preventDefault();\r\n\r\n        var clientX = getCoord('clientX', e);\r\n        var clientY = getCoord('clientY', e);\r\n        var x = clientX - _offsetX;\r\n        var y = clientY - _offsetY;\r\n\r\n        _mirror.style.left = x + 'px';\r\n        _mirror.style.top = y + 'px';\r\n\r\n        var item = _copy || _item;\r\n        var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);\r\n        var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);\r\n        var changed = dropTarget !== null && dropTarget !== _lastDropTarget;\r\n        if (changed || dropTarget === null) {\r\n          out();\r\n          _lastDropTarget = dropTarget;\r\n          over();\r\n        }\r\n        var parent = getParent(item);\r\n        if (dropTarget === _source && _copy && !o.copySortSource) {\r\n          if (parent) {\r\n            parent.removeChild(item);\r\n          }\r\n          return;\r\n        }\r\n        var reference;\r\n        var immediate = getImmediateChild(dropTarget, elementBehindCursor);\r\n        if (immediate !== null) {\r\n          reference = getReference(dropTarget, immediate, clientX, clientY);\r\n        } else if (o.revertOnSpill === true && !_copy) {\r\n          reference = _initialSibling;\r\n          dropTarget = _source;\r\n        } else {\r\n          if (_copy && parent) {\r\n            parent.removeChild(item);\r\n          }\r\n          return;\r\n        }\r\n        if (\r\n          (reference === null && changed) ||\r\n          reference !== item &&\r\n          reference !== nextEl(item)\r\n        ) {\r\n          _currentSibling = reference;\r\n          dropTarget.insertBefore(item, reference);\r\n          drake.emit('shadow', item, dropTarget, _source);\r\n        }\r\n        function moved (type) { drake.emit(type, item, _lastDropTarget, _source); }\r\n        function over () { if (changed) { moved('over'); } }\r\n        function out () { if (_lastDropTarget) { moved('out'); } }\r\n      }\r\n\r\n      function spillOver (el) {\r\n        classes.rm(el, 'gu-hide');\r\n      }\r\n\r\n      function spillOut (el) {\r\n        if (drake.dragging) { classes.add(el, 'gu-hide'); }\r\n      }\r\n\r\n      function renderMirrorImage () {\r\n        if (_mirror) {\r\n          return;\r\n        }\r\n        var rect = _item.getBoundingClientRect();\r\n        _mirror = _item.cloneNode(true);\r\n        _mirror.style.width = getRectWidth(rect) + 'px';\r\n        _mirror.style.height = getRectHeight(rect) + 'px';\r\n        classes.rm(_mirror, 'gu-transit');\r\n        classes.add(_mirror, 'gu-mirror');\r\n        o.mirrorContainer.appendChild(_mirror);\r\n        touchy(documentElement, 'add', 'mousemove', drag);\r\n        classes.add(o.mirrorContainer, 'gu-unselectable');\r\n        drake.emit('cloned', _mirror, _item, 'mirror');\r\n      }\r\n\r\n      function removeMirrorImage () {\r\n        if (_mirror) {\r\n          classes.rm(o.mirrorContainer, 'gu-unselectable');\r\n          touchy(documentElement, 'remove', 'mousemove', drag);\r\n          getParent(_mirror).removeChild(_mirror);\r\n          _mirror = null;\r\n        }\r\n      }\r\n\r\n      function getImmediateChild (dropTarget, target) {\r\n        var immediate = target;\r\n        while (immediate !== dropTarget && getParent(immediate) !== dropTarget) {\r\n          immediate = getParent(immediate);\r\n        }\r\n        if (immediate === documentElement) {\r\n          return null;\r\n        }\r\n        return immediate;\r\n      }\r\n\r\n      function getReference (dropTarget, target, x, y) {\r\n        var horizontal = o.direction === 'horizontal';\r\n        var reference = target !== dropTarget ? inside() : outside();\r\n        return reference;\r\n\r\n        function outside () { // slower, but able to figure out any position\r\n          var len = dropTarget.children.length;\r\n          var i;\r\n          var el;\r\n          var rect;\r\n          for (i = 0; i < len; i++) {\r\n            el = dropTarget.children[i];\r\n            //rect = el.getBoundingClientRect();\r\n            rect = geom.boundingRect(el);\r\n            if (horizontal && (rect.left + rect.width / 2) > x) { return el; }\r\n            if (!horizontal && (rect.top + rect.height / 2) > y) { return el; }\r\n          }\r\n          return null;\r\n        }\r\n\r\n        function inside () { // faster, but only available if dropped inside a child element\r\n          \r\n          //var rect = target.getBoundingClientRect();\r\n          var  rect = geom.boundingRect(target);\r\n          if (horizontal) {\r\n            return resolve(x > rect.left + getRectWidth(rect) / 2);\r\n          }\r\n          return resolve(y > rect.top + getRectHeight(rect) / 2);\r\n          \r\n        }\r\n\r\n        function resolve (after) {\r\n          return after ? nextEl(target) : target;\r\n        }\r\n      }\r\n\r\n      function isCopy (item, container) {\r\n        return typeof o.copy === 'boolean' ? o.copy : o.copy(item, container);\r\n      }\r\n    }\r\n\r\n\r\n    \r\n    function touchy (el, op, type, fn) {\r\n      /*\r\n      var touch = {\r\n        mouseup: 'touchend',\r\n        mousedown: 'touchstart',\r\n        mousemove: 'touchmove'\r\n      };\r\n      var pointers = {\r\n        mouseup: 'pointerup',\r\n        mousedown: 'pointerdown',\r\n        mousemove: 'pointermove'\r\n      };\r\n      var microsoft = {\r\n        mouseup: 'MSPointerUp',\r\n        mousedown: 'MSPointerDown',\r\n        mousemove: 'MSPointerMove'\r\n      };\r\n      if (global.navigator.pointerEnabled) {\r\n        crossvent[op](el, pointers[type], fn);\r\n      } else if (global.navigator.msPointerEnabled) {\r\n        crossvent[op](el, microsoft[type], fn);\r\n      } else {\r\n        crossvent[op](el, touch[type], fn);\r\n        crossvent[op](el, type, fn);\r\n      }\r\n      */\r\n      if (op == \"add\") {\r\n        eventer.on(el,type,fn);\r\n      } else {\r\n        eventer.off(el,type,fn);\r\n      }\r\n\r\n      if (!el.touchInited) {\r\n        el.touchInited = true;   \r\n        touch.mousy(el);     \r\n      }\r\n\r\n\r\n    }\r\n\r\n    function whichMouseButton (e) {\r\n    \r\n      if (e.touches !== void 0) { return e.touches.length; }\r\n      if (e.which !== void 0 && e.which !== 0) { return e.which; } // see https://github.com/bevacqua/dragula/issues/261\r\n      if (e.buttons !== void 0) { return e.buttons; }\r\n      var button = e.button;\r\n      if (button !== void 0) { // see https://github.com/jquery/jquery/blob/99e8ff1baa7ae341e94bb89c3e84570c7c3ad9ea/src/event.js#L573-L575\r\n        return button & 1 ? 1 : button & 2 ? 3 : (button & 4 ? 2 : 0);\r\n      }\r\n\r\n    }\r\n\r\n    function getOffset (el) {\r\n      /*\r\n      var rect = el.getBoundingClientRect();\r\n      return {\r\n        left: rect.left + getScroll('scrollLeft', 'pageXOffset'),\r\n        top: rect.top + getScroll('scrollTop', 'pageYOffset')\r\n      };\r\n      */\r\n      return geom.pagePosition(el);\r\n    }\r\n\r\n    /*\r\n    function getScroll (scrollProp, offsetProp) {\r\n      if (typeof global[offsetProp] !== 'undefined') {\r\n        return global[offsetProp];\r\n      }\r\n      if (documentElement.clientHeight) {\r\n        return documentElement[scrollProp];\r\n      }\r\n      return doc.body[scrollProp];\r\n    }\r\n    */\r\n\r\n    function getElementBehindPoint (point, x, y) {\r\n      //var p = point || {}; /\r\n      //var state = p.className;\r\n      var el;\r\n      //p.className += ' gu-hide'; // use point-events css property\r\n      el = doc.elementFromPoint(x, y);\r\n      //p.className = state;\r\n      return el;\r\n    }\r\n\r\n    function never () { \r\n      return false; \r\n    }\r\n    function always () { \r\n      return true; \r\n    }\r\n    function getRectWidth (rect) { \r\n      return rect.width || (rect.right - rect.left); \r\n    }\r\n    function getRectHeight (rect) { \r\n      return rect.height || (rect.bottom - rect.top); \r\n    }\r\n    function getParent (el) { \r\n      //return el.parentNode === doc ? null : el.parentNode; \r\n      return finder.parent(el);\r\n    }\r\n    function isInput (el) {\r\n      // return el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.tagName === 'SELECT' || isEditable(el); \r\n      return noder.isInput(el);\r\n   }\r\n    \r\n    \r\n    function isEditable (el) {\r\n      /*\r\n      if (!el) { return false; } // no parents were editable\r\n      if (el.contentEditable === 'false') { return false; } // stop the lookup\r\n      if (el.contentEditable === 'true') { return true; } // found a contentEditable element in the chain\r\n      return isEditable(getParent(el)); // contentEditable is set to 'inherit'\r\n      */\r\n      return noder.isEditable(el);\r\n    }\r\n    \r\n\r\n    function nextEl (el) {\r\n      /*\r\n      return el.nextElementSibling || manually();\r\n      function manually () {\r\n        var sibling = el;\r\n        do {\r\n          sibling = sibling.nextSibling;\r\n        } while (sibling && sibling.nodeType !== 1);\r\n        return sibling;\r\n      }\r\n      */\r\n      return finder.nextSibling(el);\r\n    }\r\n\r\n    function getEventHost (e) {\r\n      // on touchend event, we have to use `e.changedTouches`\r\n      // see http://stackoverflow.com/questions/7192563/touchend-event-properties\r\n      // see https://github.com/bevacqua/dragula/issues/34\r\n      if (e.targetTouches && e.targetTouches.length) {\r\n        return e.targetTouches[0];\r\n      }\r\n      if (e.changedTouches && e.changedTouches.length) {\r\n        return e.changedTouches[0];\r\n      }\r\n      return e;\r\n    }\r\n\r\n    function getCoord (coord, e) {\r\n      var host = getEventHost(e);\r\n      var missMap = {\r\n        pageX: 'clientX', // IE8\r\n        pageY: 'clientY' // IE8\r\n      };\r\n      if (coord in missMap && !(coord in host) && missMap[coord] in host) {\r\n        coord = missMap[coord];\r\n      }\r\n      return host[coord];\r\n    }\r\n\r\n    return skylark.attach(\"intg.dragula\",dragula);\r\n\r\n});\r\n"]}