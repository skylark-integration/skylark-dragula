{"version":3,"sources":["_listen.js"],"names":["define","skylark","mouse","touch","noder","finder","geom","eventer","styler","helpers","documentElement","root","drake","options","_offsetX","_offsetY","_moveX","_moveY","_grabbed","_mirror","preventGrabbed","e","preventDefault","eventualMovements","remove","op","touchy","startBecauseMouseMoved","movements","grab","clientX","clientY","whichMouseButton","metaKey","ctrlKey","item","target","context","canStart","type","isInput","focus","grabbed","end","start","offset","pagePosition","_item","getCoord","left","top","addClass","_copy","rect","getBoundingClientRect","cloneNode","style","width","getRectWidth","height","getRectHeight","removeClass","mirrorContainer","appendChild","drag","emit","renderMirrorImage","release","ungrab","parent","removeChild","dragging","dropTarget","findDropTarget","copySortSource","_source","drop","removeOnSpill","cancel","x","y","over","events"],"mappings":"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","file":"../_listen.js","sourcesContent":["define([\r\n  \"skylark-langx/skylark\",\r\n  \"skylark-devices-points/mouse\",\r\n  \"skylark-devices-points/touch\",\r\n  \"skylark-domx-noder\",\r\n  \"skylark-domx-finder\",\r\n  \"skylark-domx-geom\",\r\n  \"skylark-domx-eventer\",\r\n  \"skylark-domx-styler\",\r\n  \"./_helpers\"\r\n],function(\r\n  skylark,\r\n  mouse,\r\n  touch,\r\n  noder,\r\n  finder,\r\n  geom,\r\n  eventer,\r\n  styler,\r\n  helpers\r\n ){\r\n    'use strict';\r\n\r\n    var documentElement = noder.root(); \t\r\n\r\n\r\n\tfunction listen(drake,options) {\r\n\r\n\t\tvar _offsetX; // reference x\r\n\t    var _offsetY; // reference y\r\n\t    var _moveX; // reference move x\r\n\t    var _moveY; // reference move y\r\n\t\t\r\n\t    var _grabbed; // holds mousedown context until first mousemove\r\n\r\n\r\n\t\tvar _mirror; // mirror image\r\n\r\n\t\tfunction renderMirrorImage () {\r\n\t\t\tif (_mirror) {\r\n\t\t\t  return;\r\n\t\t\t}\r\n\t\t\tvar rect = drake._item.getBoundingClientRect();\r\n\t\t\t_mirror = drake._item.cloneNode(true);\r\n\t\t\t_mirror.style.width = helpers.getRectWidth(rect) + 'px';\r\n\t\t\t_mirror.style.height = helpers.getRectHeight(rect) + 'px';\r\n\t\t\tstyler.removeClass(_mirror, 'gu-transit');\r\n\t\t\tstyler.addClass(_mirror, 'gu-mirror');\r\n\t\t\toptions.mirrorContainer.appendChild(_mirror);\r\n\t\t\thelpers.touchy(documentElement, 'add', 'mousemove', drag);\r\n\t\t\tstyler.addClass(options.mirrorContainer, 'gu-unselectable');\r\n\t\t\tdrake.emit('cloned', _mirror, drake._item, 'mirror');\r\n\t\t}\r\n\r\n\t\tfunction removeMirrorImage () {\r\n\t\t\tif (_mirror) {\r\n\t\t\t  styler.removeClass(options.mirrorContainer, 'gu-unselectable');\r\n\t\t\t  helpers.touchy(documentElement, 'remove', 'mousemove', drag);\r\n\t\t\t  finder.parent(_mirror).removeChild(_mirror);\r\n\t\t\t  _mirror = null;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction moveMirrorImage(x,y) {\r\n\t\t\t_mirror.style.left = x + 'px';\r\n\t\t\t_mirror.style.top = y + 'px';\r\n\t\t}\r\n\r\n\t\tfunction isMirrorRendered() {\r\n\t\t  \treturn !!_mirror;\r\n\t\t}\r\n\r\n\t\tfunction preventGrabbed (e) {\r\n\t\t\tif (_grabbed) {\r\n\t\t\t  e.preventDefault();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction events (remove) {\r\n\t\t\tvar op = remove ? 'remove' : 'add';\r\n\t\t\thelpers.touchy(documentElement, op, 'mousedown', grab);\r\n\t\t\thelpers.touchy(documentElement, op, 'mouseup', release);\r\n\t\t}\r\n\r\n\t\tfunction eventualMovements (remove) {\r\n\t\t\tvar op = remove ? 'remove' : 'add';\r\n\t\t\thelpers.touchy(documentElement, op, 'mousemove', startBecauseMouseMoved);\r\n\t\t}\r\n\r\n\r\n\t\tfunction movements (remove) {\r\n\t\t\tvar op = remove ? 'off' : 'on';\r\n\t\t\teventer[op](documentElement, 'selectstart', preventGrabbed); // IE8\r\n\t\t\teventer[op](documentElement, 'click', preventGrabbed);\r\n\t\t} \r\n\r\n\t\tfunction grab (e) {\r\n\t\t\t_moveX = e.clientX;\r\n\t\t\t_moveY = e.clientY;\r\n\r\n\t\t\tvar ignore = helpers.whichMouseButton(e) !== 1 || e.metaKey || e.ctrlKey;\r\n\t\t\tif (ignore) {\r\n\t\t\t  return; // we only care about honest-to-god left clicks and touch events\r\n\t\t\t}\r\n\t\t\tvar item = e.target;\r\n\t\t\tvar context = drake.canStart(item);\r\n\t\t\tif (!context) {\r\n\t\t  \t\treturn;\r\n\t\t\t}\r\n\t\t\t_grabbed = context;\r\n\t\t\teventualMovements();\r\n\t\t\tif (e.type === 'mousedown') {\r\n\t\t  \t\tif (noder.isInput(item)) { // see also: https://github.com/bevacqua/dragula/issues/208\r\n\t\t    \t\titem.focus(); // fixes https://github.com/bevacqua/dragula/issues/176\r\n\t\t  \t\t} else {\r\n\t\t    \t\te.preventDefault(); // fixes https://github.com/bevacqua/dragula/issues/155\r\n\t\t  \t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction startBecauseMouseMoved (e) {\r\n\t\t\tif (!_grabbed) {\r\n\t\t  \t\treturn;\r\n\t\t\t}\r\n\t\t\tif (helpers.whichMouseButton(e) === 0) {\r\n\t\t  \t\trelease({});\r\n\t\t  \t\treturn; // when text is selected on an input and then dragged, mouseup doesn't fire. this is our only hope\r\n\t\t\t}\r\n\t\t\t// truthy check fixes #239, equality fixes #207\r\n\t\t\tif (e.clientX !== void 0 && e.clientX === _moveX && e.clientY !== void 0 && e.clientY === _moveY) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tvar grabbed = _grabbed; // call to end() unsets _grabbed\r\n\t\t\teventualMovements(true);\r\n\t\t\tmovements();\r\n\t\t\tdrake.end();\r\n\t\t\tdrake.start(grabbed);\r\n\r\n\t\t\tvar offset = geom.pagePosition(drake._item);\r\n\t\t\t_offsetX = helpers.getCoord('pageX', e) - offset.left;\r\n\t\t\t_offsetY = helpers.getCoord('pageY', e) - offset.top;\r\n\r\n\t\t\tstyler.addClass(drake._copy || drake._item, 'gu-transit');\r\n\t\t\trenderMirrorImage();\r\n\t\t\tdrag(e);\r\n\t\t}\r\n\r\n\t\tfunction ungrab () {\r\n\t\t\t_grabbed = false;\r\n\t\t\teventualMovements(true);\r\n\t\t\tmovements(true);\r\n\t\t}\r\n\r\n\t\tfunction release (e) {\r\n\t\t\tungrab();\r\n            removeMirrorImage();\r\n\t\t\tif (!drake.dragging) {\r\n\t\t\t  return;\r\n\t\t\t}\r\n\t\t\tvar item = drake._copy || drake._item;\r\n\t\t\tvar clientX = helpers.getCoord('clientX', e);\r\n\t\t\tvar clientY = helpers.getCoord('clientY', e);\r\n\t\t\tvar dropTarget = drake.findDropTarget(clientX, clientY);\r\n\t\t\tif (dropTarget && ((drake._copy &&  options.copySortSource) || (!drake._copy || dropTarget !== drake._source))) {\r\n\t\t\t  drake.drop(item, dropTarget);\r\n\t\t\t} else if (options.removeOnSpill) {\r\n\t\t\t  drake.remove();\r\n\t\t\t} else {\r\n\t\t\t  drake.cancel();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction drag (e) {\r\n\t\t\tif (!isMirrorRendered()) {\r\n\t\t\t  return;\r\n\t\t\t}\r\n\t\t\te.preventDefault();\r\n\r\n\t\t\tvar clientX = helpers.getCoord('clientX', e);\r\n\t\t\tvar clientY = helpers.getCoord('clientY', e);\r\n\r\n\r\n\t\t\tmoveMirrorImage(clientX - _offsetX,clientY - _offsetY);\r\n\r\n\t\t\tdrake.over(clientX,clientY);\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tevents,\r\n\t\t\tgrab,\r\n\t\t\tungrab,\r\n\t\t\trelease\r\n\t\t}\r\n\t}\r\n\r\n\treturn listen;\r\n});"]}